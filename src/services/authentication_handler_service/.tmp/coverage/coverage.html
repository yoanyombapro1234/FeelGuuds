
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proto: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto/authentication_handler_service.pb.go (66.5%)</option>
				
				<option value="file1">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/cache.go (0.0%)</option>
				
				<option value="file2">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/chunked.go (80.0%)</option>
				
				<option value="file3">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/configs.go (0.0%)</option>
				
				<option value="file4">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/delay.go (27.8%)</option>
				
				<option value="file5">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/echo.go (15.6%)</option>
				
				<option value="file6">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/echows.go (0.0%)</option>
				
				<option value="file7">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/env.go (0.0%)</option>
				
				<option value="file8">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/headers.go (100.0%)</option>
				
				<option value="file9">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/health.go (33.3%)</option>
				
				<option value="file10">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/http.go (31.9%)</option>
				
				<option value="file11">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/index.go (0.0%)</option>
				
				<option value="file12">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/info.go (100.0%)</option>
				
				<option value="file13">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/logging.go (0.0%)</option>
				
				<option value="file14">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/metrics.go (0.0%)</option>
				
				<option value="file15">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/mock.go (89.7%)</option>
				
				<option value="file16">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/panic.go (0.0%)</option>
				
				<option value="file17">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/server.go (0.0%)</option>
				
				<option value="file18">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/status.go (66.7%)</option>
				
				<option value="file19">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/store.go (0.0%)</option>
				
				<option value="file20">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/token.go (0.0%)</option>
				
				<option value="file21">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/version.go (100.0%)</option>
				
				<option value="file22">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/authenticate_account.go (80.8%)</option>
				
				<option value="file23">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/create_account.go (80.0%)</option>
				
				<option value="file24">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/delete_account.go (95.2%)</option>
				
				<option value="file25">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/get_account.go (82.1%)</option>
				
				<option value="file26">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/lock_account.go (95.2%)</option>
				
				<option value="file27">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/logout_account.go (95.0%)</option>
				
				<option value="file28">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/mock.go (64.3%)</option>
				
				<option value="file29">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/rpcUtils.go (95.5%)</option>
				
				<option value="file30">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/server.go (0.0%)</option>
				
				<option value="file31">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/third_party_mock.go (80.0%)</option>
				
				<option value="file32">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/trace.go (100.0%)</option>
				
				<option value="file33">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/unlock_account.go (95.2%)</option>
				
				<option value="file34">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/update_account.go (95.0%)</option>
				
				<option value="file35">github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/grpc/util.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/authentication_handler_service.proto

package proto

import (
        bytes "bytes"
        context "context"
        fmt "fmt"
        io "io"
        math "math"
        math_bits "math/bits"

        proto "github.com/gogo/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// create account api request
type CreateAccountRequest struct {
        Email                string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAccountRequest) Reset()         <span class="cov8" title="1">{ *m = CreateAccountRequest{} }</span>
func (m *CreateAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{0}
}</span>
func (m *CreateAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *CreateAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CreateAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *CreateAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateAccountRequest.Merge(m, src)
}</span>
func (m *CreateAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *CreateAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateAccountRequest proto.InternalMessageInfo

func (m *CreateAccountRequest) GetEmail() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CreateAccountRequest) GetPassword() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// create account api response
type CreateAccountResponse struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAccountResponse) Reset()         <span class="cov8" title="1">{ *m = CreateAccountResponse{} }</span>
func (m *CreateAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{1}
}</span>
func (m *CreateAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *CreateAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CreateAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *CreateAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateAccountResponse.Merge(m, src)
}</span>
func (m *CreateAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *CreateAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateAccountResponse proto.InternalMessageInfo

func (m *CreateAccountResponse) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CreateAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// update account api request
type UpdateAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Email                string   `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateAccountRequest) Reset()         <span class="cov8" title="1">{ *m = UpdateAccountRequest{} }</span>
func (m *UpdateAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{2}
}</span>
func (m *UpdateAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *UpdateAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UpdateAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *UpdateAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAccountRequest.Merge(m, src)
}</span>
func (m *UpdateAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *UpdateAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateAccountRequest proto.InternalMessageInfo

func (m *UpdateAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UpdateAccountRequest) GetEmail() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// update account api response
type UpdateAccountResponse struct {
        Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateAccountResponse) Reset()         <span class="cov8" title="1">{ *m = UpdateAccountResponse{} }</span>
func (m *UpdateAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{3}
}</span>
func (m *UpdateAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *UpdateAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UpdateAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *UpdateAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAccountResponse.Merge(m, src)
}</span>
func (m *UpdateAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *UpdateAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateAccountResponse proto.InternalMessageInfo

func (m *UpdateAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// delete account api request
type DeleteAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAccountRequest) Reset()         <span class="cov8" title="1">{ *m = DeleteAccountRequest{} }</span>
func (m *DeleteAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{4}
}</span>
func (m *DeleteAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *DeleteAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DeleteAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *DeleteAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteAccountRequest.Merge(m, src)
}</span>
func (m *DeleteAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *DeleteAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteAccountRequest proto.InternalMessageInfo

func (m *DeleteAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// delete account api response
type DeleteAccountResponse struct {
        Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAccountResponse) Reset()         <span class="cov8" title="1">{ *m = DeleteAccountResponse{} }</span>
func (m *DeleteAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{5}
}</span>
func (m *DeleteAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *DeleteAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_DeleteAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *DeleteAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteAccountResponse.Merge(m, src)
}</span>
func (m *DeleteAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *DeleteAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteAccountResponse proto.InternalMessageInfo

func (m *DeleteAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// lock account api request
type LockAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LockAccountRequest) Reset()         <span class="cov8" title="1">{ *m = LockAccountRequest{} }</span>
func (m *LockAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LockAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LockAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{6}
}</span>
func (m *LockAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *LockAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_LockAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *LockAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LockAccountRequest.Merge(m, src)
}</span>
func (m *LockAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *LockAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LockAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LockAccountRequest proto.InternalMessageInfo

func (m *LockAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// lock account api response
type LockAccountResponse struct {
        Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LockAccountResponse) Reset()         <span class="cov8" title="1">{ *m = LockAccountResponse{} }</span>
func (m *LockAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LockAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LockAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{7}
}</span>
func (m *LockAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *LockAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_LockAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *LockAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LockAccountResponse.Merge(m, src)
}</span>
func (m *LockAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *LockAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LockAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LockAccountResponse proto.InternalMessageInfo

func (m *LockAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// unlock account api request
type UnLockAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UnLockAccountRequest) Reset()         <span class="cov8" title="1">{ *m = UnLockAccountRequest{} }</span>
func (m *UnLockAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UnLockAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UnLockAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{8}
}</span>
func (m *UnLockAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *UnLockAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UnLockAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *UnLockAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UnLockAccountRequest.Merge(m, src)
}</span>
func (m *UnLockAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *UnLockAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UnLockAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UnLockAccountRequest proto.InternalMessageInfo

func (m *UnLockAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// unlock account api response
type UnLockAccountResponse struct {
        Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UnLockAccountResponse) Reset()         <span class="cov8" title="1">{ *m = UnLockAccountResponse{} }</span>
func (m *UnLockAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UnLockAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UnLockAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{9}
}</span>
func (m *UnLockAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *UnLockAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UnLockAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *UnLockAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UnLockAccountResponse.Merge(m, src)
}</span>
func (m *UnLockAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *UnLockAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UnLockAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UnLockAccountResponse proto.InternalMessageInfo

func (m *UnLockAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// get account api request
type GetAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountRequest) Reset()         <span class="cov8" title="1">{ *m = GetAccountRequest{} }</span>
func (m *GetAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{10}
}</span>
func (m *GetAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *GetAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GetAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *GetAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetAccountRequest.Merge(m, src)
}</span>
func (m *GetAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *GetAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetAccountRequest proto.InternalMessageInfo

func (m *GetAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// get account api response
type GetAccountResponse struct {
        Account              *Account `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
        Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountResponse) Reset()         <span class="cov8" title="1">{ *m = GetAccountResponse{} }</span>
func (m *GetAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{11}
}</span>
func (m *GetAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *GetAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GetAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *GetAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetAccountResponse.Merge(m, src)
}</span>
func (m *GetAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *GetAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetAccountResponse proto.InternalMessageInfo

func (m *GetAccountResponse) GetAccount() *Account <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Account
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *GetAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// authenticate account request
type AuthenticateAccountRequest struct {
        Email                string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticateAccountRequest) Reset()         <span class="cov8" title="1">{ *m = AuthenticateAccountRequest{} }</span>
func (m *AuthenticateAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AuthenticateAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AuthenticateAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{12}
}</span>
func (m *AuthenticateAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *AuthenticateAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AuthenticateAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *AuthenticateAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AuthenticateAccountRequest.Merge(m, src)
}</span>
func (m *AuthenticateAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *AuthenticateAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AuthenticateAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AuthenticateAccountRequest proto.InternalMessageInfo

func (m *AuthenticateAccountRequest) GetEmail() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuthenticateAccountRequest) GetPassword() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// authenticate account response
type AuthenticateAccountResponse struct {
        Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
        Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticateAccountResponse) Reset()         <span class="cov8" title="1">{ *m = AuthenticateAccountResponse{} }</span>
func (m *AuthenticateAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AuthenticateAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AuthenticateAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{13}
}</span>
func (m *AuthenticateAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *AuthenticateAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_AuthenticateAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *AuthenticateAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AuthenticateAccountResponse.Merge(m, src)
}</span>
func (m *AuthenticateAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *AuthenticateAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AuthenticateAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AuthenticateAccountResponse proto.InternalMessageInfo

func (m *AuthenticateAccountResponse) GetToken() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AuthenticateAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// logout api request
type LogoutAccountRequest struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LogoutAccountRequest) Reset()         <span class="cov8" title="1">{ *m = LogoutAccountRequest{} }</span>
func (m *LogoutAccountRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LogoutAccountRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LogoutAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{14}
}</span>
func (m *LogoutAccountRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *LogoutAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_LogoutAccountRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *LogoutAccountRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LogoutAccountRequest.Merge(m, src)
}</span>
func (m *LogoutAccountRequest) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *LogoutAccountRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LogoutAccountRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LogoutAccountRequest proto.InternalMessageInfo

func (m *LogoutAccountRequest) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// logout api response
type LogoutAccountResponse struct {
        Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LogoutAccountResponse) Reset()         <span class="cov8" title="1">{ *m = LogoutAccountResponse{} }</span>
func (m *LogoutAccountResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LogoutAccountResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LogoutAccountResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{15}
}</span>
func (m *LogoutAccountResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *LogoutAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_LogoutAccountResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *LogoutAccountResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LogoutAccountResponse.Merge(m, src)
}</span>
func (m *LogoutAccountResponse) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *LogoutAccountResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LogoutAccountResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LogoutAccountResponse proto.InternalMessageInfo

func (m *LogoutAccountResponse) GetError() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ==== Common ====
// account representation
type Account struct {
        Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Locked               bool     `protobuf:"varint,3,opt,name=locked,proto3" json:"locked,omitempty"`
        Deleted              bool     `protobuf:"varint,4,opt,name=deleted,proto3" json:"deleted,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Account) Reset()         <span class="cov8" title="1">{ *m = Account{} }</span>
func (m *Account) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Account) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Account) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6a27991b06087dd2, []int{16}
}</span>
func (m *Account) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return m.Unmarshal(b)
}</span>
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Account.Marshal(b, m, deterministic)
        }</span> else<span class="cov8" title="1"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return b[:n], nil</span>
        }
}
func (m *Account) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Account.Merge(m, src)
}</span>
func (m *Account) XXX_Size() int <span class="cov8" title="1">{
        return m.Size()
}</span>
func (m *Account) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Account.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() uint32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Account) GetUsername() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Account) GetLocked() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Locked
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Account) GetDeleted() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Deleted
        }</span>
        <span class="cov0" title="0">return false</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*CreateAccountRequest)(nil), "CreateAccountRequest")
        proto.RegisterType((*CreateAccountResponse)(nil), "CreateAccountResponse")
        proto.RegisterType((*UpdateAccountRequest)(nil), "UpdateAccountRequest")
        proto.RegisterType((*UpdateAccountResponse)(nil), "UpdateAccountResponse")
        proto.RegisterType((*DeleteAccountRequest)(nil), "DeleteAccountRequest")
        proto.RegisterType((*DeleteAccountResponse)(nil), "DeleteAccountResponse")
        proto.RegisterType((*LockAccountRequest)(nil), "LockAccountRequest")
        proto.RegisterType((*LockAccountResponse)(nil), "LockAccountResponse")
        proto.RegisterType((*UnLockAccountRequest)(nil), "UnLockAccountRequest")
        proto.RegisterType((*UnLockAccountResponse)(nil), "UnLockAccountResponse")
        proto.RegisterType((*GetAccountRequest)(nil), "GetAccountRequest")
        proto.RegisterType((*GetAccountResponse)(nil), "GetAccountResponse")
        proto.RegisterType((*AuthenticateAccountRequest)(nil), "AuthenticateAccountRequest")
        proto.RegisterType((*AuthenticateAccountResponse)(nil), "AuthenticateAccountResponse")
        proto.RegisterType((*LogoutAccountRequest)(nil), "LogoutAccountRequest")
        proto.RegisterType((*LogoutAccountResponse)(nil), "LogoutAccountResponse")
        proto.RegisterType((*Account)(nil), "Account")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("proto/authentication_handler_service.proto", fileDescriptor_6a27991b06087dd2)
}</span>

var fileDescriptor_6a27991b06087dd2 = []byte{
        // 523 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xd1, 0x8a, 0xd3, 0x40,
        0x18, 0x85, 0x99, 0xba, 0xbb, 0xad, 0xff, 0x12, 0xc1, 0x69, 0x12, 0xc2, 0xac, 0xc4, 0x35, 0xca,
        0xb2, 0x28, 0x8e, 0xb0, 0x22, 0x78, 0xa1, 0x85, 0xaa, 0xa0, 0xc2, 0xb2, 0x48, 0x61, 0x6f, 0xbc,
        0x59, 0x62, 0x32, 0xec, 0x86, 0x76, 0x67, 0xe2, 0x64, 0xa2, 0x6f, 0x24, 0x3e, 0x82, 0x8f, 0xe0,
        0xa5, 0x8f, 0xa0, 0x79, 0x0a, 0x2f, 0x25, 0xd3, 0x64, 0x9b, 0xb4, 0xd3, 0x66, 0xc1, 0xab, 0xf2,
        0x77, 0x4e, 0xce, 0x7f, 0x32, 0x3d, 0x1f, 0x85, 0x87, 0xa9, 0x14, 0x4a, 0x3c, 0x09, 0x73, 0x75,
        0xc1, 0xb8, 0x4a, 0xa2, 0x50, 0x25, 0x82, 0x9f, 0x5d, 0x84, 0x3c, 0x9e, 0x31, 0x79, 0x96, 0x31,
        0xf9, 0x25, 0x89, 0x18, 0xd5, 0xa2, 0xe0, 0x1d, 0xd8, 0xaf, 0x25, 0x0b, 0x15, 0x1b, 0x47, 0x91,
        0xc8, 0xb9, 0x9a, 0xb0, 0xcf, 0x39, 0xcb, 0x14, 0xb6, 0x61, 0x9b, 0x5d, 0x86, 0xc9, 0xcc, 0x43,
        0xfb, 0xe8, 0xf0, 0xe6, 0x64, 0x3e, 0x60, 0x02, 0x83, 0x34, 0xcc, 0xb2, 0xaf, 0x42, 0xc6, 0x5e,
        0x4f, 0x1f, 0x5c, 0xcd, 0xc1, 0x4b, 0x70, 0x96, 0x9c, 0xb2, 0x54, 0xf0, 0x8c, 0xe1, 0x5b, 0xd0,
        0x4b, 0x62, 0xed, 0x63, 0x4d, 0x7a, 0x49, 0xac, 0xad, 0xa5, 0x14, 0xb2, 0x72, 0x98, 0x0f, 0xc1,
        0x0b, 0xb0, 0x4f, 0xd3, 0x78, 0x35, 0x88, 0xe9, 0x69, 0x1d, 0xac, 0xd7, 0x08, 0x16, 0x3c, 0x06,
        0x67, 0xe9, 0xe9, 0x6a, 0xf9, 0xd5, 0x32, 0xd4, 0x5c, 0x76, 0x00, 0xf6, 0x1b, 0x36, 0x63, 0x5d,
        0xcb, 0x4a, 0xdb, 0x25, 0xdd, 0x46, 0xdb, 0x07, 0x80, 0x8f, 0x45, 0x34, 0xed, 0x30, 0x7d, 0x04,
        0xc3, 0x96, 0xaa, 0x2b, 0xe9, 0x29, 0xbf, 0x86, 0x69, 0x79, 0x01, 0xfc, 0xfa, 0xb6, 0xf7, 0xe1,
        0xf6, 0x5b, 0xa6, 0x3a, 0x3c, 0x4f, 0x00, 0x37, 0x45, 0x95, 0x61, 0x00, 0xfd, 0x70, 0xfe, 0x95,
        0x96, 0xee, 0x1e, 0x0d, 0x68, 0x2d, 0xa9, 0x0f, 0xd6, 0xfc, 0xc4, 0x27, 0x40, 0xc6, 0x8b, 0x4e,
        0xfe, 0x7f, 0xe3, 0xde, 0xc3, 0x9e, 0xd1, 0x6f, 0xf1, 0xe6, 0x4a, 0x4c, 0x19, 0xaf, 0x0d, 0xf5,
        0xb0, 0x26, 0xda, 0x01, 0xd8, 0xc7, 0xe2, 0x5c, 0xe4, 0xaa, 0xfb, 0x9a, 0x97, 0x74, 0x1b, 0xaf,
        0xf9, 0x1c, 0xfa, 0x95, 0x70, 0xa5, 0xc7, 0x04, 0x06, 0x79, 0xc6, 0x24, 0x0f, 0x2f, 0x59, 0xfd,
        0x62, 0xf5, 0x8c, 0x5d, 0xd8, 0x99, 0x89, 0x68, 0xca, 0x62, 0xef, 0xc6, 0x3e, 0x3a, 0x1c, 0x4c,
        0xaa, 0x09, 0x7b, 0xd0, 0x8f, 0x75, 0x1d, 0x63, 0x6f, 0x4b, 0x1f, 0xd4, 0xe3, 0xd1, 0xb7, 0x2d,
        0xb8, 0xb7, 0x99, 0xf7, 0x71, 0x9a, 0xe0, 0x11, 0x58, 0x2d, 0x44, 0xb1, 0x43, 0x4d, 0xf0, 0x13,
        0x97, 0x9a, 0x49, 0x1e, 0x81, 0xd5, 0xa2, 0x0c, 0x3b, 0xd4, 0xc4, 0x2c, 0x71, 0xa9, 0x19, 0xc6,
        0x11, 0x58, 0x2d, 0x9c, 0xb0, 0x43, 0x4d, 0x18, 0x12, 0x97, 0x9a, 0xa9, 0x7b, 0x0e, 0xbb, 0x8d,
        0x8a, 0xe3, 0x21, 0x5d, 0x05, 0x83, 0xd8, 0xd4, 0x44, 0x41, 0x99, 0xbc, 0x89, 0x47, 0x99, 0xdc,
        0x80, 0x55, 0x99, 0xdc, 0x48, 0xd1, 0x33, 0x80, 0x05, 0x0a, 0x18, 0xd3, 0x15, 0x78, 0xc8, 0x90,
        0x1a, 0x58, 0xf9, 0x00, 0x43, 0x43, 0x43, 0xf1, 0x1e, 0x5d, 0xcf, 0x01, 0xb9, 0x43, 0x37, 0x95,
        0x7a, 0x04, 0x56, 0xab, 0x80, 0xd8, 0xa1, 0xa6, 0xe2, 0x12, 0x97, 0x1a, 0x7b, 0xfa, 0xea, 0xee,
        0xdf, 0x3f, 0x3e, 0xfa, 0x5e, 0xf8, 0xe8, 0x47, 0xe1, 0xa3, 0x9f, 0x85, 0x8f, 0x7e, 0x15, 0x3e,
        0xfa, 0x5d, 0xf8, 0xe8, 0xe3, 0xb6, 0xfe, 0x43, 0xf8, 0xb4, 0xa3, 0x3f, 0x9e, 0xfe, 0x0b, 0x00,
        0x00, 0xff, 0xff, 0xdc, 0x4f, 0xd9, 0x33, 0x45, 0x06, 0x00, 0x00,
}

func (this *CreateAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*CreateAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(CreateAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Email != that1.Email </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Password != that1.Password </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *CreateAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*CreateAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(CreateAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *UpdateAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*UpdateAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(UpdateAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Email != that1.Email </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *UpdateAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*UpdateAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(UpdateAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *DeleteAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*DeleteAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(DeleteAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *DeleteAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*DeleteAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(DeleteAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *LockAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*LockAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(LockAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *LockAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*LockAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(LockAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *UnLockAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*UnLockAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(UnLockAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *UnLockAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*UnLockAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(UnLockAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *GetAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*GetAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(GetAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *GetAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*GetAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(GetAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !this.Account.Equal(that1.Account) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *AuthenticateAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*AuthenticateAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(AuthenticateAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Email != that1.Email </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Password != that1.Password </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *AuthenticateAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*AuthenticateAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(AuthenticateAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Token != that1.Token </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *LogoutAccountRequest) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*LogoutAccountRequest)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(LogoutAccountRequest)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *LogoutAccountResponse) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*LogoutAccountResponse)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(LogoutAccountResponse)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Error != that1.Error </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
func (this *Account) Equal(that interface{}) bool <span class="cov8" title="1">{
        if that == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span>

        <span class="cov8" title="1">that1, ok := that.(*Account)
        if !ok </span><span class="cov0" title="0">{
                that2, ok := that.(Account)
                if ok </span><span class="cov0" title="0">{
                        that1 = &amp;that2
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">if that1 == nil </span><span class="cov0" title="0">{
                return this == nil
        }</span> else<span class="cov8" title="1"> if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Id != that1.Id </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Username != that1.Username </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Locked != that1.Locked </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if this.Deleted != that1.Deleted </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthenticationHandlerServiceApiClient is the client API for AuthenticationHandlerServiceApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthenticationHandlerServiceApiClient interface {
        // create account
        CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error)
        // update account
        UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*UpdateAccountResponse, error)
        // delete account
        DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error)
        // lock account
        LockAccount(ctx context.Context, in *LockAccountRequest, opts ...grpc.CallOption) (*LockAccountResponse, error)
        // unlock account
        UnLockAccount(ctx context.Context, in *UnLockAccountRequest, opts ...grpc.CallOption) (*UnLockAccountResponse, error)
        // get account
        GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*GetAccountResponse, error)
        // authenticate account
        AuthenticateAccount(ctx context.Context, in *AuthenticateAccountRequest, opts ...grpc.CallOption) (*AuthenticateAccountResponse, error)
        // log out account
        LogoutAccount(ctx context.Context, in *LogoutAccountRequest, opts ...grpc.CallOption) (*LogoutAccountResponse, error)
}

type authenticationHandlerServiceApiClient struct {
        cc *grpc.ClientConn
}

func NewAuthenticationHandlerServiceApiClient(cc *grpc.ClientConn) AuthenticationHandlerServiceApiClient <span class="cov0" title="0">{
        return &amp;authenticationHandlerServiceApiClient{cc}
}</span>

func (c *authenticationHandlerServiceApiClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*CreateAccountResponse, error) <span class="cov0" title="0">{
        out := new(CreateAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/CreateAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*UpdateAccountResponse, error) <span class="cov0" title="0">{
        out := new(UpdateAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/UpdateAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error) <span class="cov0" title="0">{
        out := new(DeleteAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/DeleteAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) LockAccount(ctx context.Context, in *LockAccountRequest, opts ...grpc.CallOption) (*LockAccountResponse, error) <span class="cov0" title="0">{
        out := new(LockAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/LockAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) UnLockAccount(ctx context.Context, in *UnLockAccountRequest, opts ...grpc.CallOption) (*UnLockAccountResponse, error) <span class="cov0" title="0">{
        out := new(UnLockAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/UnLockAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*GetAccountResponse, error) <span class="cov0" title="0">{
        out := new(GetAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/GetAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) AuthenticateAccount(ctx context.Context, in *AuthenticateAccountRequest, opts ...grpc.CallOption) (*AuthenticateAccountResponse, error) <span class="cov0" title="0">{
        out := new(AuthenticateAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/AuthenticateAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authenticationHandlerServiceApiClient) LogoutAccount(ctx context.Context, in *LogoutAccountRequest, opts ...grpc.CallOption) (*LogoutAccountResponse, error) <span class="cov0" title="0">{
        out := new(LogoutAccountResponse)
        err := c.cc.Invoke(ctx, "/authentication_handler_serviceApi/LogoutAccount", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthenticationHandlerServiceApiServer is the server API for AuthenticationHandlerServiceApi service.
type AuthenticationHandlerServiceApiServer interface {
        // create account
        CreateAccount(context.Context, *CreateAccountRequest) (*CreateAccountResponse, error)
        // update account
        UpdateAccount(context.Context, *UpdateAccountRequest) (*UpdateAccountResponse, error)
        // delete account
        DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error)
        // lock account
        LockAccount(context.Context, *LockAccountRequest) (*LockAccountResponse, error)
        // unlock account
        UnLockAccount(context.Context, *UnLockAccountRequest) (*UnLockAccountResponse, error)
        // get account
        GetAccount(context.Context, *GetAccountRequest) (*GetAccountResponse, error)
        // authenticate account
        AuthenticateAccount(context.Context, *AuthenticateAccountRequest) (*AuthenticateAccountResponse, error)
        // log out account
        LogoutAccount(context.Context, *LogoutAccountRequest) (*LogoutAccountResponse, error)
}

// UnimplementedAuthenticationHandlerServiceApiServer can be embedded to have forward compatible implementations.
type UnimplementedAuthenticationHandlerServiceApiServer struct {
}

func (*UnimplementedAuthenticationHandlerServiceApiServer) CreateAccount(ctx context.Context, req *CreateAccountRequest) (*CreateAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) UpdateAccount(ctx context.Context, req *UpdateAccountRequest) (*UpdateAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) DeleteAccount(ctx context.Context, req *DeleteAccountRequest) (*DeleteAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) LockAccount(ctx context.Context, req *LockAccountRequest) (*LockAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method LockAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) UnLockAccount(ctx context.Context, req *UnLockAccountRequest) (*UnLockAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UnLockAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) GetAccount(ctx context.Context, req *GetAccountRequest) (*GetAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) AuthenticateAccount(ctx context.Context, req *AuthenticateAccountRequest) (*AuthenticateAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AuthenticateAccount not implemented")
}</span>
func (*UnimplementedAuthenticationHandlerServiceApiServer) LogoutAccount(ctx context.Context, req *LogoutAccountRequest) (*LogoutAccountResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method LogoutAccount not implemented")
}</span>

func RegisterAuthenticationHandlerServiceApiServer(s *grpc.Server, srv AuthenticationHandlerServiceApiServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_AuthenticationHandlerServiceApi_serviceDesc, srv)
}</span>

func _AuthenticationHandlerServiceApi_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).CreateAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/CreateAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).CreateAccount(ctx, req.(*CreateAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).UpdateAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/UpdateAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).UpdateAccount(ctx, req.(*UpdateAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).DeleteAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/DeleteAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_LockAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LockAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).LockAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/LockAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).LockAccount(ctx, req.(*LockAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_UnLockAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UnLockAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).UnLockAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/UnLockAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).UnLockAccount(ctx, req.(*UnLockAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).GetAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/GetAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).GetAccount(ctx, req.(*GetAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_AuthenticateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AuthenticateAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).AuthenticateAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/AuthenticateAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).AuthenticateAccount(ctx, req.(*AuthenticateAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthenticationHandlerServiceApi_LogoutAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).LogoutAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/authentication_handler_serviceApi/LogoutAccount",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthenticationHandlerServiceApiServer).LogoutAccount(ctx, req.(*LogoutAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _AuthenticationHandlerServiceApi_serviceDesc = grpc.ServiceDesc{
        ServiceName: "authentication_handler_serviceApi",
        HandlerType: (*AuthenticationHandlerServiceApiServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateAccount",
                        Handler:    _AuthenticationHandlerServiceApi_CreateAccount_Handler,
                },
                {
                        MethodName: "UpdateAccount",
                        Handler:    _AuthenticationHandlerServiceApi_UpdateAccount_Handler,
                },
                {
                        MethodName: "DeleteAccount",
                        Handler:    _AuthenticationHandlerServiceApi_DeleteAccount_Handler,
                },
                {
                        MethodName: "LockAccount",
                        Handler:    _AuthenticationHandlerServiceApi_LockAccount_Handler,
                },
                {
                        MethodName: "UnLockAccount",
                        Handler:    _AuthenticationHandlerServiceApi_UnLockAccount_Handler,
                },
                {
                        MethodName: "GetAccount",
                        Handler:    _AuthenticationHandlerServiceApi_GetAccount_Handler,
                },
                {
                        MethodName: "AuthenticateAccount",
                        Handler:    _AuthenticationHandlerServiceApi_AuthenticateAccount_Handler,
                },
                {
                        MethodName: "LogoutAccount",
                        Handler:    _AuthenticationHandlerServiceApi_LogoutAccount_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/authentication_handler_service.proto",
}

func (m *CreateAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CreateAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CreateAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Password) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Password)
                copy(dAtA[i:], m.Password)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Password)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Email) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Email)
                copy(dAtA[i:], m.Email)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Email)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *CreateAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CreateAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CreateAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *UpdateAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UpdateAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UpdateAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Email) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Email)
                copy(dAtA[i:], m.Email)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Email)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *UpdateAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UpdateAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UpdateAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *DeleteAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DeleteAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DeleteAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *DeleteAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *DeleteAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *DeleteAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *LockAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *LockAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *LockAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *LockAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *LockAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *LockAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *UnLockAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UnLockAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UnLockAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *UnLockAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UnLockAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UnLockAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *GetAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GetAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GetAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *GetAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GetAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GetAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Account != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        size, err := m.Account.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">i -= size
                        i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(size))</span>
                }
                <span class="cov8" title="1">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AuthenticateAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AuthenticateAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AuthenticateAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Password) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Password)
                copy(dAtA[i:], m.Password)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Password)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Email) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Email)
                copy(dAtA[i:], m.Email)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Email)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *AuthenticateAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *AuthenticateAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *AuthenticateAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if len(m.Token) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Token)
                copy(dAtA[i:], m.Token)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Token)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *LogoutAccountRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *LogoutAccountRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *LogoutAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *LogoutAccountResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *LogoutAccountResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *LogoutAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if len(m.Error) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Error)
                copy(dAtA[i:], m.Error)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Error)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func (m *Account) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) <span class="cov8" title="1">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov8" title="1">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                i -= len(m.XXX_unrecognized)
                copy(dAtA[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">if m.Deleted </span><span class="cov8" title="1">{
                i--
                if m.Deleted </span><span class="cov8" title="1">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov8" title="1">i--
                dAtA[i] = 0x20</span>
        }
        <span class="cov8" title="1">if m.Locked </span><span class="cov8" title="1">{
                i--
                if m.Locked </span><span class="cov8" title="1">{
                        dAtA[i] = 1
                }</span> else<span class="cov0" title="0"> {
                        dAtA[i] = 0
                }</span>
                <span class="cov8" title="1">i--
                dAtA[i] = 0x18</span>
        }
        <span class="cov8" title="1">if len(m.Username) &gt; 0 </span><span class="cov8" title="1">{
                i -= len(m.Username)
                copy(dAtA[i:], m.Username)
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(len(m.Username)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov8" title="1">if m.Id != 0 </span><span class="cov8" title="1">{
                i = encodeVarintAuthenticationHandlerService(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov8" title="1">return len(dAtA) - i, nil</span>
}

func encodeVarintAuthenticationHandlerService(dAtA []byte, offset int, v uint64) int <span class="cov8" title="1">{
        offset -= sovAuthenticationHandlerService(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov8" title="1">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov8" title="1">dAtA[offset] = uint8(v)
        return base</span>
}
func NewPopulatedCreateAccountRequest(r randyAuthenticationHandlerService, easy bool) *CreateAccountRequest <span class="cov8" title="1">{
        this := &amp;CreateAccountRequest{}
        this.Email = string(randStringAuthenticationHandlerService(r))
        this.Password = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedCreateAccountResponse(r randyAuthenticationHandlerService, easy bool) *CreateAccountResponse <span class="cov8" title="1">{
        this := &amp;CreateAccountResponse{}
        this.Id = uint32(r.Uint32())
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedUpdateAccountRequest(r randyAuthenticationHandlerService, easy bool) *UpdateAccountRequest <span class="cov8" title="1">{
        this := &amp;UpdateAccountRequest{}
        this.Id = uint32(r.Uint32())
        this.Email = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedUpdateAccountResponse(r randyAuthenticationHandlerService, easy bool) *UpdateAccountResponse <span class="cov8" title="1">{
        this := &amp;UpdateAccountResponse{}
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedDeleteAccountRequest(r randyAuthenticationHandlerService, easy bool) *DeleteAccountRequest <span class="cov8" title="1">{
        this := &amp;DeleteAccountRequest{}
        this.Id = uint32(r.Uint32())
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedDeleteAccountResponse(r randyAuthenticationHandlerService, easy bool) *DeleteAccountResponse <span class="cov8" title="1">{
        this := &amp;DeleteAccountResponse{}
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedLockAccountRequest(r randyAuthenticationHandlerService, easy bool) *LockAccountRequest <span class="cov8" title="1">{
        this := &amp;LockAccountRequest{}
        this.Id = uint32(r.Uint32())
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedLockAccountResponse(r randyAuthenticationHandlerService, easy bool) *LockAccountResponse <span class="cov8" title="1">{
        this := &amp;LockAccountResponse{}
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedUnLockAccountRequest(r randyAuthenticationHandlerService, easy bool) *UnLockAccountRequest <span class="cov8" title="1">{
        this := &amp;UnLockAccountRequest{}
        this.Id = uint32(r.Uint32())
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedUnLockAccountResponse(r randyAuthenticationHandlerService, easy bool) *UnLockAccountResponse <span class="cov8" title="1">{
        this := &amp;UnLockAccountResponse{}
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov0" title="0">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedGetAccountRequest(r randyAuthenticationHandlerService, easy bool) *GetAccountRequest <span class="cov8" title="1">{
        this := &amp;GetAccountRequest{}
        this.Id = uint32(r.Uint32())
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedGetAccountResponse(r randyAuthenticationHandlerService, easy bool) *GetAccountResponse <span class="cov8" title="1">{
        this := &amp;GetAccountResponse{}
        if r.Intn(5) != 0 </span><span class="cov8" title="1">{
                this.Account = NewPopulatedAccount(r, easy)
        }</span>
        <span class="cov8" title="1">this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedAuthenticateAccountRequest(r randyAuthenticationHandlerService, easy bool) *AuthenticateAccountRequest <span class="cov8" title="1">{
        this := &amp;AuthenticateAccountRequest{}
        this.Email = string(randStringAuthenticationHandlerService(r))
        this.Password = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedAuthenticateAccountResponse(r randyAuthenticationHandlerService, easy bool) *AuthenticateAccountResponse <span class="cov8" title="1">{
        this := &amp;AuthenticateAccountResponse{}
        this.Token = string(randStringAuthenticationHandlerService(r))
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 3)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedLogoutAccountRequest(r randyAuthenticationHandlerService, easy bool) *LogoutAccountRequest <span class="cov8" title="1">{
        this := &amp;LogoutAccountRequest{}
        this.Id = uint32(r.Uint32())
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedLogoutAccountResponse(r randyAuthenticationHandlerService, easy bool) *LogoutAccountResponse <span class="cov8" title="1">{
        this := &amp;LogoutAccountResponse{}
        this.Error = string(randStringAuthenticationHandlerService(r))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 2)
        }</span>
        <span class="cov8" title="1">return this</span>
}

func NewPopulatedAccount(r randyAuthenticationHandlerService, easy bool) *Account <span class="cov8" title="1">{
        this := &amp;Account{}
        this.Id = uint32(r.Uint32())
        this.Username = string(randStringAuthenticationHandlerService(r))
        this.Locked = bool(bool(r.Intn(2) == 0))
        this.Deleted = bool(bool(r.Intn(2) == 0))
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov8" title="1">{
                this.XXX_unrecognized = randUnrecognizedAuthenticationHandlerService(r, 5)
        }</span>
        <span class="cov8" title="1">return this</span>
}

type randyAuthenticationHandlerService interface {
        Float32() float32
        Float64() float64
        Int63() int64
        Int31() int32
        Uint32() uint32
        Intn(n int) int
}

func randUTF8RuneAuthenticationHandlerService(r randyAuthenticationHandlerService) rune <span class="cov8" title="1">{
        ru := r.Intn(62)
        if ru &lt; 10 </span><span class="cov8" title="1">{
                return rune(ru + 48)
        }</span> else<span class="cov8" title="1"> if ru &lt; 36 </span><span class="cov8" title="1">{
                return rune(ru + 55)
        }</span>
        <span class="cov8" title="1">return rune(ru + 61)</span>
}
func randStringAuthenticationHandlerService(r randyAuthenticationHandlerService) string <span class="cov8" title="1">{
        v1 := r.Intn(100)
        tmps := make([]rune, v1)
        for i := 0; i &lt; v1; i++ </span><span class="cov8" title="1">{
                tmps[i] = randUTF8RuneAuthenticationHandlerService(r)
        }</span>
        <span class="cov8" title="1">return string(tmps)</span>
}
func randUnrecognizedAuthenticationHandlerService(r randyAuthenticationHandlerService, maxFieldNumber int) (dAtA []byte) <span class="cov8" title="1">{
        l := r.Intn(5)
        for i := 0; i &lt; l; i++ </span><span class="cov8" title="1">{
                wire := r.Intn(4)
                if wire == 3 </span><span class="cov8" title="1">{
                        wire = 5
                }</span>
                <span class="cov8" title="1">fieldNumber := maxFieldNumber + r.Intn(100)
                dAtA = randFieldAuthenticationHandlerService(dAtA, r, fieldNumber, wire)</span>
        }
        <span class="cov8" title="1">return dAtA</span>
}
func randFieldAuthenticationHandlerService(dAtA []byte, r randyAuthenticationHandlerService, fieldNumber int, wire int) []byte <span class="cov8" title="1">{
        key := uint32(fieldNumber)&lt;&lt;3 | uint32(wire)
        switch wire </span>{
        case 0:<span class="cov8" title="1">
                dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(key))
                v2 := r.Int63()
                if r.Intn(2) == 0 </span><span class="cov8" title="1">{
                        v2 *= -1
                }</span>
                <span class="cov8" title="1">dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(v2))</span>
        case 1:<span class="cov8" title="1">
                dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(key))
                dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        case 2:<span class="cov8" title="1">
                dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(key))
                ll := r.Intn(100)
                dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(ll))
                for j := 0; j &lt; ll; j++ </span><span class="cov8" title="1">{
                        dAtA = append(dAtA, byte(r.Intn(256)))
                }</span>
        default:<span class="cov8" title="1">
                dAtA = encodeVarintPopulateAuthenticationHandlerService(dAtA, uint64(key))
                dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        }
        <span class="cov8" title="1">return dAtA</span>
}
func encodeVarintPopulateAuthenticationHandlerService(dAtA []byte, v uint64) []byte <span class="cov8" title="1">{
        for v &gt;= 1&lt;&lt;7 </span><span class="cov8" title="1">{
                dAtA = append(dAtA, uint8(uint64(v)&amp;0x7f|0x80))
                v &gt;&gt;= 7
        }</span>
        <span class="cov8" title="1">dAtA = append(dAtA, uint8(v))
        return dAtA</span>
}
func (m *CreateAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Email)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Password)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *CreateAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *UpdateAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">l = len(m.Email)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *UpdateAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *DeleteAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *DeleteAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *LockAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *LockAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *UnLockAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *UnLockAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *GetAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *GetAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Account != nil </span><span class="cov8" title="1">{
                l = m.Account.Size()
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AuthenticateAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Email)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Password)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *AuthenticateAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Token)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *LogoutAccountRequest) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov0" title="0">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *LogoutAccountResponse) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        l = len(m.Error)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (m *Account) Size() (n int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">var l int
        _ = l
        if m.Id != 0 </span><span class="cov8" title="1">{
                n += 1 + sovAuthenticationHandlerService(uint64(m.Id))
        }</span>
        <span class="cov8" title="1">l = len(m.Username)
        if l &gt; 0 </span><span class="cov8" title="1">{
                n += 1 + l + sovAuthenticationHandlerService(uint64(l))
        }</span>
        <span class="cov8" title="1">if m.Locked </span><span class="cov8" title="1">{
                n += 2
        }</span>
        <span class="cov8" title="1">if m.Deleted </span><span class="cov8" title="1">{
                n += 2
        }</span>
        <span class="cov8" title="1">if m.XXX_unrecognized != nil </span><span class="cov8" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov8" title="1">return n</span>
}

func sovAuthenticationHandlerService(x uint64) (n int) <span class="cov8" title="1">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAuthenticationHandlerService(x uint64) (n int) <span class="cov0" title="0">{
        return sovAuthenticationHandlerService(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *CreateAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CreateAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CreateAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Email = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Password = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *CreateAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: CreateAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CreateAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *UpdateAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: UpdateAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Email = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *UpdateAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *DeleteAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DeleteAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: DeleteAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *DeleteAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DeleteAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: DeleteAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *LockAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LockAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LockAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *LockAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: LockAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LockAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *UnLockAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UnLockAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UnLockAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *UnLockAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: UnLockAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UnLockAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *GetAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: GetAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GetAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *GetAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GetAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GetAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov8" title="1">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
                        }</span>
                        <span class="cov8" title="1">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">if m.Account == nil </span><span class="cov8" title="1">{
                                m.Account = &amp;Account{}
                        }</span>
                        <span class="cov8" title="1">if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AuthenticateAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuthenticateAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuthenticateAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov8" title="1">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Email = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Password = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *AuthenticateAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuthenticateAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: AuthenticateAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Token = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov8" title="1">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *LogoutAccountRequest) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LogoutAccountRequest: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LogoutAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *LogoutAccountResponse) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LogoutAccountResponse: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: LogoutAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Error = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov8" title="1">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (m *Account) Unmarshal(dAtA []byte) error <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Account: wiretype end group for non-group")
                }</span>
                <span class="cov8" title="1">if fieldNum &lt;= 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov8" title="1">switch fieldNum </span>{
                case 1:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov8" title="1">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint32(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov8" title="1">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
                        }</span>
                        <span class="cov8" title="1">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.Username = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
                        }</span>
                        <span class="cov8" title="1">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">m.Locked = bool(v != 0)</span>
                case 4:<span class="cov8" title="1">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
                        }</span>
                        <span class="cov8" title="1">var v int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">m.Deleted = bool(v != 0)</span>
                default:<span class="cov8" title="1">
                        iNdEx = preIndex
                        skippy, err := skipAuthenticationHandlerService(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if skippy &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
                        iNdEx += skippy</span>
                }
        }

        <span class="cov8" title="1">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func skipAuthenticationHandlerService(dAtA []byte) (n int, err error) <span class="cov8" title="1">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov8" title="1">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov8" title="1">
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov8" title="1">
                        iNdEx += 8</span>
                case 2:<span class="cov8" title="1">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov8" title="1">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAuthenticationHandlerService
                                }</span>
                                <span class="cov8" title="1">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov8" title="1">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">iNdEx += length</span>
                case 3:<span class="cov8" title="1">
                        depth++</span>
                case 4:<span class="cov8" title="1">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAuthenticationHandlerService
                        }</span>
                        <span class="cov8" title="1">depth--</span>
                case 5:<span class="cov8" title="1">
                        iNdEx += 4</span>
                default:<span class="cov8" title="1">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov8" title="1">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAuthenticationHandlerService
                }</span>
                <span class="cov8" title="1">if depth == 0 </span><span class="cov8" title="1">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAuthenticationHandlerService        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAuthenticationHandlerService          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAuthenticationHandlerService = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "io/ioutil"
        "net/http"
        "time"

        "github.com/gomodule/redigo/redis"
        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/version"
)

// Cache godoc
// @Summary Save payload in cache
// @Description writes the posted content in cache
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /cache/{key} [post]
// @Success 202
func (s *Server) cacheWriteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]
        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "reading the request body failed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">conn := s.pool.Get()
        defer conn.Close()
        _, err = conn.Do("SET", key, string(body))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.InfoM("cache set failed", zap.Error(err))
                s.ErrorResponse(w, r, "cache set failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)</span>
}

// Cache godoc
// @Summary Delete payload from cache
// @Description deletes the key and its value from cache
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /cache/{key} [delete]
// @Success 202
func (s *Server) cacheDeleteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]

        conn := s.pool.Get()
        defer conn.Close()
        _, err := conn.Do("DEL", key)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Info("cache delete failed", zap.Error(err))
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)</span>
}

// Cache godoc
// @Summary Get payload from cache
// @Description returns the content from cache if key exists
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /cache/{key} [get]
// @Success 200 {string} string value
func (s *Server) cacheReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if s.pool == nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "cache server is offline", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">key := mux.Vars(r)["key"]

        conn := s.pool.Get()
        defer conn.Close()

        ok, err := redis.Bool(conn.Do("EXISTS", key))
        if err != nil || !ok </span><span class="cov0" title="0">{
                s.logger.InfoM("cache key not found", zap.String("key", key))
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">data, err := redis.String(conn.Do("GET", key))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Info("cache get failed", zap.Error(err))
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte(data))</span>
}

func (s *Server) startCachePool(ticker *time.Ticker, stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        if s.config.CacheServer == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.pool = &amp;redis.Pool{
                MaxIdle:     3,
                IdleTimeout: 240 * time.Second,
                Dial: func() (redis.Conn, error) </span><span class="cov0" title="0">{
                        return redis.Dial("tcp", s.config.CacheServer)
                }</span>,
                TestOnBorrow: func(c redis.Conn, t time.Time) error <span class="cov0" title="0">{
                        _, err := c.Do("PING")
                        return err
                }</span>,
        }

        // set &lt;hostname&gt;=&lt;version&gt; with an expiry time of one minute
        <span class="cov0" title="0">setVersion := func() </span><span class="cov0" title="0">{
                conn := s.pool.Get()
                if _, err := conn.Do("SET", s.config.Hostname, version.VERSION, "EX", 60); err != nil </span><span class="cov0" title="0">{
                        s.logger.Info("cache server is offline", zap.Error(err), zap.String("server", s.config.CacheServer))
                }</span>
                <span class="cov0" title="0">_ = conn.Close()</span>
        }

        // set version on a schedule
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                setVersion()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-stopCh:<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                setVersion()</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "math/rand"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
)

// Chunked godoc
// @Summary Chunked transfer encoding
// @Description uses transfer-encoding type chunked to give a partial response and then waits for the specified period
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /chunked/{seconds} [get]
// @Success 200 {object} api.MapResponse
func (s *Server) chunkedHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)

        delay, err := strconv.Atoi(vars["wait"])
        if err != nil </span><span class="cov0" title="0">{
                delay = rand.Intn(int(s.config.HttpServerTimeout*time.Second)-10) + 10
        }</span>

        <span class="cov8" title="1">flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "Streaming unsupported!", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Connection", "Keep-Alive")
        w.Header().Set("Transfer-Encoding", "chunked")
        w.Header().Set("X-Content-Type-Options", "nosniff")

        flusher.Flush()

        time.Sleep(time.Duration(delay) * time.Second)
        s.JSONResponse(w, r, map[string]int{"delay": delay})

        flusher.Flush()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import "net/http"

func (s *Server) configReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        files := make(map[string]string)
        if watcher != nil </span><span class="cov0" title="0">{
                watcher.Cache.Range(func(key interface{}, value interface{}) bool </span><span class="cov0" title="0">{
                        files[key.(string)] = value.(string)
                        return true
                }</span>)
        }

        <span class="cov0" title="0">s.JSONResponse(w, r, files)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "math/rand"
        "net/http"

        "strconv"
        "time"

        "github.com/gorilla/mux"
)

type RandomDelayMiddleware struct {
        min  int
        max  int
        unit string
}

func NewRandomDelayMiddleware(minDelay, maxDelay int, delayUnit string) *RandomDelayMiddleware <span class="cov0" title="0">{
        return &amp;RandomDelayMiddleware{
                min:  minDelay,
                max:  maxDelay,
                unit: delayUnit,
        }
}</span>

func (m *RandomDelayMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var unit time.Duration
                rand.Seed(time.Now().Unix())
                switch m.unit </span>{
                case "s":<span class="cov0" title="0">
                        unit = time.Second</span>
                case "ms":<span class="cov0" title="0">
                        unit = time.Millisecond</span>
                default:<span class="cov0" title="0">
                        unit = time.Second</span>
                }

                <span class="cov0" title="0">delay := rand.Intn(m.max-m.min) + m.min
                time.Sleep(time.Duration(delay) * unit)
                next.ServeHTTP(w, r)</span>
        })
}

// Delay godoc
// @Summary Delay
// @Description waits for the specified period
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /delay/{seconds} [get]
// @Success 200 {object} api.MapResponse
func (s *Server) delayHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)

        delay, err := strconv.Atoi(vars["wait"])
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">time.Sleep(time.Duration(delay) * time.Second)

        s.JSONResponse(w, r, map[string]int{"delay": delay})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "bytes"
        "context"
        "fmt"
        "io/ioutil"
        "net/http"
        "sync"

        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/version"
)

// Echo godoc
// @Summary Echo
// @Description forwards the call to the backend service and echos the posted content
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /api/echo [post]
// @Success 202 {object} api.MapResponse
func (s *Server) echoHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err, "reading the request body failed", zap.Error(err))
                s.ErrorResponse(w, r, "invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()
        if len(s.config.BackendURL) &gt; 0 </span><span class="cov0" title="0">{
                result := make([]string, len(s.config.BackendURL))
                var wg sync.WaitGroup
                wg.Add(len(s.config.BackendURL))
                for i, b := range s.config.BackendURL </span><span class="cov0" title="0">{
                        go func(index int, backend string) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                backendReq, err := http.NewRequest("POST", backend, bytes.NewReader(body))
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error(err, "backend call failed", zap.Error(err), zap.String("url", backend))
                                        return
                                }</span>

                                // forward headers
                                <span class="cov0" title="0">copyTracingHeaders(r, backendReq)

                                backendReq.Header.Set("X-API-Version", version.VERSION)
                                backendReq.Header.Set("X-API-Revision", version.REVISION)

                                ctx, cancel := context.WithTimeout(backendReq.Context(), s.config.HttpClientTimeout)
                                defer cancel()

                                // call backend
                                resp, err := http.DefaultClient.Do(backendReq.WithContext(ctx))
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error(err, "backend call failed", zap.Error(err), zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v call failed %v", backend, err)
                                        return
                                }</span>
                                <span class="cov0" title="0">defer resp.Body.Close()

                                // copy error status from backend and exit
                                if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                                        s.logger.Error(err, "backend call failed", zap.Int("status", resp.StatusCode), zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v response status code %v", backend, resp.StatusCode)
                                        return
                                }</span>

                                // forward the received body
                                <span class="cov0" title="0">rbody, err := ioutil.ReadAll(resp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error(err,
                                                "reading the backend request body failed",
                                                zap.Error(err),
                                                zap.String("url", backend))
                                        result[index] = fmt.Sprintf("backend %v call failed %v", backend, err)
                                        return
                                }</span>

                                <span class="cov0" title="0">s.logger.Info(
                                        "payload received from backend",
                                        zap.String("response", string(rbody)),
                                        zap.String("url", backend))

                                result[index] = string(rbody)</span>
                        }(i, b)
                }
                <span class="cov0" title="0">wg.Wait()

                w.Header().Set("X-Color", s.config.UIColor)
                s.JSONResponse(w, r, result)</span>

        } else<span class="cov8" title="1"> {
                w.Header().Set("X-Color", s.config.UIColor)
                w.WriteHeader(http.StatusAccepted)
                w.Write(body)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "net/http"
        "strings"
        "time"

        "github.com/gorilla/websocket"
        "go.uber.org/zap"
)

var wsCon = websocket.Upgrader{}

// EchoWS godoc
// @Summary Echo over websockets
// @Description echos content via websockets
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /ws/echo [post]
// @Success 202 {object} api.MapResponse
// Test: go run ./cmd/servicecli/* ws localhost:9898/ws/echo
func (s *Server) echoWsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        c, err := wsCon.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Info("websocket upgrade error", zap.Error(err))
                        return
                }</span>
        }
        <span class="cov0" title="0">defer c.Close()
        done := make(chan struct{})
        defer close(done)
        in := make(chan interface{})
        defer close(in)
        go s.writeWs(c, in)
        go s.sendHostWs(c, in, done)
        for </span><span class="cov0" title="0">{
                _, message, err := c.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if !strings.Contains(err.Error(), "close") </span><span class="cov0" title="0">{
                                s.logger.Info("websocket read error", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">var response = struct {
                        Time    time.Time `json:"ts"`
                        Message string    `json:"msg"`
                }{
                        Time:    time.Now(),
                        Message: string(message),
                }
                in &lt;- response</span>
        }
}

func (s *Server) sendHostWs(ws *websocket.Conn, in chan interface{}, done chan struct{}) <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        var status = struct {
                                Time time.Time `json:"ts"`
                                Host string    `json:"server"`
                        }{
                                Time: time.Now(),
                                Host: s.config.Hostname,
                        }
                        in &lt;- status</span>
                case &lt;-done:<span class="cov0" title="0">
                        s.logger.Info("websocket exit")
                        return</span>
                }
        }
}

func (s *Server) writeWs(ws *websocket.Conn, in chan interface{}) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-in:<span class="cov0" title="0">
                        if err := ws.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                                if !strings.Contains(err.Error(), "close") </span><span class="cov0" title="0">{
                                        s.logger.Info("websocket write error", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "net/http"

        "os"
)

// Env godoc
// @Summary Environment
// @Description returns the environment variables as a JSON array
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /env [get]
// @Success 200 {object} api.ArrayResponse
func (s *Server) envHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.JSONResponse(w, r, os.Environ())
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/http"
)

// Headers godoc
// @Summary Headers
// @Description returns a JSON array with the request HTTP headers
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /headers [get]
// @Success 200 {object} api.ArrayResponse
func (s *Server) echoHeadersHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        s.JSONResponse(w, r, r.Header)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "net/http"
        "sync/atomic"
)

// Healthz godoc
// @Summary Liveness check
// @Description used by Kubernetes liveness probe
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /healthz [get]
// @Success 200 {string} string "OK"
func (s *Server) healthzHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;healthy) == 1 </span><span class="cov0" title="0">{
                s.JSONResponse(w, r, map[string]string{"status": "OK"})
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusServiceUnavailable)</span>
}

// Readyz godoc
// @Summary Readiness check
// @Description used by Kubernetes readiness probe
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz [get]
// @Success 200 {string} string "OK"
func (s *Server) readyzHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;ready) == 1 </span><span class="cov0" title="0">{
                s.JSONResponse(w, r, map[string]string{"status": "OK"})
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusServiceUnavailable)</span>
}

// EnableReady godoc
// @Summary Enable ready state
// @Description signals the Kubernetes LB that this instance is ready to receive traffic
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz/enable [post]
// @Success 202 {string} string "OK"
func (s *Server) enableReadyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;ready, 1)
        w.WriteHeader(http.StatusAccepted)
}</span>

// DisableReady godoc
// @Summary Disable ready state
// @Description signals the Kubernetes LB to stop sending requests to this instance
// @Tags Kubernetes
// @Accept json
// @Produce json
// @Router /readyz/disable [post]
// @Success 202 {string} string "OK"
func (s *Server) disableReadyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;ready, 0)
        w.WriteHeader(http.StatusAccepted)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "bytes"
        "encoding/json"
        "math/rand"
        "net/http"
        "time"

        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/version"
)

func randomErrorMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rand.Seed(time.Now().Unix())
                if rand.Int31n(3) == 0 </span><span class="cov0" title="0">{

                        errors := []int{http.StatusInternalServerError, http.StatusBadRequest, http.StatusConflict}
                        w.WriteHeader(errors[rand.Intn(len(errors))])
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func versionMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                r.Header.Set("X-API-Version", version.VERSION)
                r.Header.Set("X-API-Revision", version.REVISION)

                next.ServeHTTP(w, r)
        }</span>)
}

// TODO: use Istio tracing package
// https://github.com/istio/istio/blob/master/pkg/tracing/config.go
func copyTracingHeaders(from *http.Request, to *http.Request) <span class="cov0" title="0">{
        headers := []string{
                "x-request-id",
                "x-b3-traceid",
                "x-b3-spanid",
                "x-b3-parentspanid",
                "x-b3-sampled",
                "x-b3-flags",
                "x-ot-span-context",
        }

        for i := range headers </span><span class="cov0" title="0">{
                headerValue := from.Header.Get(headers[i])
                if len(headerValue) &gt; 0 </span><span class="cov0" title="0">{
                        to.Header.Set(headers[i], headerValue)
                }</span>
        }
}

func (s *Server) JSONResponse(w http.ResponseWriter, r *http.Request, result interface{}) <span class="cov8" title="1">{
        body, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error(err, "JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(http.StatusOK)
        w.Write(prettyJSON(body))</span>
}

func (s *Server) JSONResponseCode(w http.ResponseWriter, r *http.Request, result interface{}, responseCode int) <span class="cov8" title="1">{
        body, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error(err, "JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(responseCode)
        w.Write(prettyJSON(body))</span>
}

func (s *Server) ErrorResponse(w http.ResponseWriter, r *http.Request, error string, code int) <span class="cov0" title="0">{
        data := struct {
                Code    int    `json:"code"`
                Message string `json:"message"`
        }{
                Code:    code,
                Message: error,
        }

        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                s.logger.Error(err, "JSON marshal failed", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(http.StatusOK)
        w.Write(prettyJSON(body))</span>
}

func prettyJSON(b []byte) []byte <span class="cov8" title="1">{
        var out bytes.Buffer
        json.Indent(&amp;out, b, "", "  ")
        return out.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "html/template"
        "net/http"
        "path"
)

// Index godoc
// @Summary Index
// @Description renders service UI
// @Tags HTTP API
// @Produce html
// @Router / [get]
// @Success 200 {string} string "OK"
func (s *Server) indexHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tmpl, err := template.New("vue.html").ParseFiles(path.Join(s.config.UIPath, "vue.html"))
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte(path.Join(s.config.UIPath, "vue.html") + err.Error()))
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                Logo  string
        }{
                Title: s.config.Hostname,
                Logo:  s.config.UILogo,
        }

        if err := tmpl.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, path.Join(s.config.UIPath, "vue.html")+err.Error(), http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "net/http"
        "runtime"
        "strconv"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/version"
)

// Info godoc
// @Summary Runtime information
// @Description returns the runtime information
// @Tags HTTP API
// @Accept json
// @Produce json
// @Success 200 {object} api.RuntimeResponse
// @Router /api/info [get]
func (s *Server) infoHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        data := RuntimeResponse{
                Hostname:     s.config.Hostname,
                Version:      version.VERSION,
                Revision:     version.REVISION,
                Logo:         s.config.UILogo,
                Color:        s.config.UIColor,
                Message:      s.config.UIMessage,
                GOOS:         runtime.GOOS,
                GOARCH:       runtime.GOARCH,
                Runtime:      runtime.Version(),
                NumGoroutine: strconv.FormatInt(int64(runtime.NumGoroutine()), 10),
                NumCPU:       strconv.FormatInt(int64(runtime.NumCPU()), 10),
        }

        s.JSONResponse(w, r, data)
}</span>

type RuntimeResponse struct {
        Hostname     string `json:"hostname"`
        Version      string `json:"version"`
        Revision     string `json:"revision"`
        Color        string `json:"color"`
        Logo         string `json:"logo"`
        Message      string `json:"message"`
        GOOS         string `json:"goos"`
        GOARCH       string `json:"goarch"`
        Runtime      string `json:"runtime"`
        NumGoroutine string `json:"num_goroutine"`
        NumCPU       string `json:"num_cpu"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "net/http"

        core_logging "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-logging/json"
        "go.uber.org/zap"
)

type LoggingMiddleware struct {
        logger core_logging.ILog
}

func NewLoggingMiddleware(logger core_logging.ILog) *LoggingMiddleware <span class="cov0" title="0">{
        return &amp;LoggingMiddleware{
                logger: logger,
        }
}</span>

func (m *LoggingMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logger.InfoM(
                        "request started",
                        zap.String("proto", r.Proto),
                        zap.String("uri", r.RequestURI),
                        zap.String("method", r.Method),
                        zap.String("remote", r.RemoteAddr),
                        zap.String("user-agent", r.UserAgent()),
                )
                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "bufio"
        "fmt"
        "io"
        "net"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus"
)

type PrometheusMiddleware struct {
        Histogram *prometheus.HistogramVec
        Counter   *prometheus.CounterVec
}

func NewPrometheusMiddleware() *PrometheusMiddleware <span class="cov0" title="0">{
        // used for monitoring and alerting (RED method)
        histogram := prometheus.NewHistogramVec(prometheus.HistogramOpts{
                Subsystem: "http",
                Name:      "request_duration_seconds",
                Help:      "Seconds spent serving HTTP requests.",
                Buckets:   prometheus.DefBuckets,
        }, []string{"method", "path", "status"})
        // used for horizontal pod auto-scaling (Kubernetes HPA v2)
        counter := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Subsystem: "http",
                        Name:      "requests_total",
                        Help:      "The total number of HTTP requests.",
                },
                []string{"status"},
        )

        prometheus.MustRegister(histogram)
        prometheus.MustRegister(counter)

        return &amp;PrometheusMiddleware{
                Histogram: histogram,
                Counter:   counter,
        }
}</span>

// Metrics godoc
// @Summary Prometheus metrics
// @Description returns HTTP requests duration and Go runtime metrics
// @Tags Kubernetes
// @Produce plain
// @Router /metrics [get]
// @Success 200 {string} string "OK"
func (p *PrometheusMiddleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                begin := time.Now()
                interceptor := &amp;interceptor{ResponseWriter: w, statusCode: http.StatusOK}
                path := p.getRouteName(r)
                next.ServeHTTP(interceptor.wrappedResponseWriter(), r)
                var (
                        status = strconv.Itoa(interceptor.statusCode)
                        took   = time.Since(begin)
                )
                p.Histogram.WithLabelValues(r.Method, path, status).Observe(took.Seconds())
                p.Counter.WithLabelValues(status).Inc()
        }</span>)
}

// converts gorilla mux routes from '/api/delay/{wait}' to 'api_delay_wait'
func (p *PrometheusMiddleware) getRouteName(r *http.Request) string <span class="cov0" title="0">{
        if mux.CurrentRoute(r) != nil </span><span class="cov0" title="0">{
                if name := mux.CurrentRoute(r).GetName(); len(name) &gt; 0 </span><span class="cov0" title="0">{
                        return urlToLabel(name)
                }</span>
                <span class="cov0" title="0">if path, err := mux.CurrentRoute(r).GetPathTemplate(); err == nil </span><span class="cov0" title="0">{
                        if len(path) &gt; 0 </span><span class="cov0" title="0">{
                                return urlToLabel(path)
                        }</span>
                }
        }
        <span class="cov0" title="0">return urlToLabel(r.RequestURI)</span>
}

var invalidChars = regexp.MustCompile(`[^a-zA-Z0-9]+`)

// converts a URL path to a string compatible with Prometheus label value.
func urlToLabel(path string) string <span class="cov0" title="0">{
        result := invalidChars.ReplaceAllString(path, "_")
        result = strings.ToLower(strings.Trim(result, "_"))
        if result == "" </span><span class="cov0" title="0">{
                result = "root"
        }</span>
        <span class="cov0" title="0">return result</span>
}

type interceptor struct {
        http.ResponseWriter
        statusCode int
        recorded   bool
}

func (i *interceptor) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        hj, ok := i.ResponseWriter.(http.Hijacker)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("interceptor: can't cast parent ResponseWriter to Hijacker")
        }</span>
        <span class="cov0" title="0">return hj.Hijack()</span>
}

func (i *interceptor) WriteHeader(code int) <span class="cov0" title="0">{
        if !i.recorded </span><span class="cov0" title="0">{
                i.statusCode = code
                i.recorded = true
        }</span>
        <span class="cov0" title="0">i.ResponseWriter.WriteHeader(code)</span>
}

// Returns a wrapped http.ResponseWriter that implements the same optional interfaces
// that the underlying ResponseWriter has.
// Handle every possible combination so that code that checks for the existence of each
// optional interface functions properly.
// Based on https://github.com/felixge/httpsnoop/blob/eadd4fad6aac69ae62379194fe0219f3dbc80fd3/wrap_generated_gteq_1.8.go#L66
func (i *interceptor) wrappedResponseWriter() http.ResponseWriter <span class="cov0" title="0">{
        closeNotifier, isCloseNotifier := i.ResponseWriter.(http.CloseNotifier)
        flush, isFlusher := i.ResponseWriter.(http.Flusher)
        hijack, isHijacker := i.ResponseWriter.(http.Hijacker)
        push, isPusher := i.ResponseWriter.(http.Pusher)
        readFrom, isReaderFrom := i.ResponseWriter.(io.ReaderFrom)

        switch </span>{
        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                }{i}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                }{i, closeNotifier}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                }{i, flush}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                }{i, hijack}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Pusher
                }{i, push}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        io.ReaderFrom
                }{i, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                }{i, closeNotifier, flush}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                }{i, closeNotifier, hijack}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Pusher
                }{i, closeNotifier, push}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        io.ReaderFrom
                }{i, closeNotifier, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                }{i, flush, hijack}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Pusher
                }{i, flush, push}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        io.ReaderFrom
                }{i, flush, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        http.Pusher
                }{i, hijack, push}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        io.ReaderFrom
                }{i, hijack, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Pusher
                        io.ReaderFrom
                }{i, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                }{i, closeNotifier, flush, hijack}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Pusher
                }{i, closeNotifier, flush, push}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        http.Pusher
                }{i, closeNotifier, hijack, push}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        io.ReaderFrom
                }{i, closeNotifier, hijack, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                }{i, flush, hijack, push}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        io.ReaderFrom
                }{i, flush, hijack, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Pusher
                        io.ReaderFrom
                }{i, flush, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, hijack, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; !isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                }{i, closeNotifier, flush, hijack, push}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; !isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        io.ReaderFrom
                }{i, closeNotifier, flush, hijack, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; !isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; !isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, hijack, push, readFrom}</span>

        case !isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, flush, hijack, push, readFrom}</span>

        case isCloseNotifier &amp;&amp; isFlusher &amp;&amp; isHijacker &amp;&amp; isPusher &amp;&amp; isReaderFrom:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                        http.CloseNotifier
                        http.Flusher
                        http.Hijacker
                        http.Pusher
                        io.ReaderFrom
                }{i, closeNotifier, flush, hijack, push, readFrom}</span>

        default:<span class="cov0" title="0">
                return struct {
                        http.ResponseWriter
                }{i}</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "context"
        "io"
        "time"

        "github.com/gorilla/mux"
        "github.com/opentracing/opentracing-go"
        "github.com/uber/jaeger-lib/metrics/prometheus"
        "go.uber.org/zap"

        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
        core_logging "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-logging/json"
        core_metrics "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-metrics"
        core_tracing "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-tracing"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/metrics"
)

func NewMockServer() *Server <span class="cov8" title="1">{
        config := &amp;Config{
                Port:                      "9898",
                HttpServerShutdownTimeout: 5 * time.Second,
                HttpServerTimeout:         30 * time.Second,
                BackendURL:                []string{},
                ConfigPath:                "/config",
                DataPath:                  "/data",
                HttpClientTimeout:         30 * time.Second,
                UIColor:                   "blue",
                UIPath:                    ".ui",
                UIMessage:                 "Greetings",
                Hostname:                  "localhost",
        }

        const serviceName string = "test"

        // initiate tracing engine
        tracerEngine, closer := InitializeTracingEngine(serviceName)
        defer closer.Close()
        ctx := context.Background()

        // initiate metrics engine
        serviceMetrics := InitializeMetricsEngine(serviceName)

        // initiate logging client
        logger := InitializeLoggingEngine(ctx)

        // authn client
        authnClient, err := InitializeAuthnClient(logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.For(ctx).FatalM(err, "unable to setup mock server")
        }</span>

        <span class="cov8" title="1">srv := &amp;Server{
                router:        mux.NewRouter(),
                config:        config,
                tracerEngine:  tracerEngine,
                metricsEngine: serviceMetrics.Engine,
                metrics:       serviceMetrics.MicroServiceMetrics,
                logger:        logger,
                authnClient:   authnClient,
        }

        // authMw := middleware.NewAuthnMw(srv.authnClient, srv.logger)
        // srv.router.Use(authMw.AuthenticationMiddleware)

        return srv</span>
}

func InitializeAuthnClient(logger core_logging.ILog) (*core_auth_sdk.Client, error) <span class="cov8" title="1">{
        // TODO Move this to errors folder
        const username string = "blackspaceinc"
        const password string = "blackspaceinc"
        const audience string = "localhost"
        const issuer string = "http://localhost:8404"
        const origin string = "http://localhost"
        const privateBaseUrl string = "http://localhost:8404"

        client, err := core_auth_sdk.NewClient(core_auth_sdk.Config{
                // The AUTHN_URL of your Keratin AuthN server. This will be used to verify tokens created by
                // AuthN, and will also be used for API calls unless PrivateBaseURL is also set.
                Issuer: issuer,

                // The domain of your application (no protocol). This domain should be listed in the APP_DOMAINS
                // of your Keratin AuthN server.
                Audience: audience,

                // Credentials for AuthN's private endpoints. These will be used to execute admin actions using
                // the Client provided by this library.
                //
                // TIP: make them extra secure in production!
                Username: username,
                Password: password,

                // RECOMMENDED: Send private API calls to AuthN using private network routing. This can be
                // necessary if your environment has a firewall to limit public endpoints.
                PrivateBaseURL: privateBaseUrl,
        }, origin)

        // TODO: make this a retryable operation
        retries := 1
        for retries &lt; 4 </span><span class="cov8" title="1">{
                // perform a test request to the authentication service
                data, err := client.ServerStats()
                if err != nil </span><span class="cov8" title="1">{
                        if retries != 4 </span><span class="cov8" title="1">{
                                logger.ErrorM(err, "failed to connect to authentication service")
                        }</span> else<span class="cov0" title="0"> {
                                logger.FatalM(err, "failed to connect to authentication service")
                        }</span>
                        <span class="cov8" title="1">retries += 1</span>
                } else<span class="cov0" title="0"> {
                        retries = 4
                        logger.InfoM("data", zap.Any("result", data))
                }</span>

                <span class="cov8" title="1">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov8" title="1">return client, err</span>
}

func InitializeLoggingEngine(ctx context.Context) core_logging.ILog <span class="cov8" title="1">{
        // initiate authn client
        rootSpan := opentracing.SpanFromContext(ctx)

        // create logging object
        logger := core_logging.NewJSONLogger(nil, rootSpan)
        return logger
}</span>

func InitializeMetricsEngine(serviceName string) *metrics.MetricsEngine <span class="cov8" title="1">{
        coreMetrics := core_metrics.NewCoreMetricsEngineInstance(serviceName, nil)
        serviceMetrics := metrics.NewMetricsEngine(coreMetrics, "mock")
        return serviceMetrics
}</span>

func InitializeTracingEngine(serviceName string) (*core_tracing.TracingEngine, io.Closer) <span class="cov8" title="1">{
        // TODO move this to constant folder
        const collectorEndpoint string = "http://localhost:14268/api/traces"

        // initiaize a tracing object globally
        return core_tracing.NewTracer(serviceName, collectorEndpoint, prometheus.New())
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package api

import (
        "errors"
        "net/http"
)

// Panic godoc
// @Summary Panic
// @Description crashes the process with exit code 255
// @Tags HTTP API
// @Router /panic [get]
func (s *Server) panicHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.logger.FatalM(errors.New("panic command received"), "Panic command received")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        _ "net/http/pprof"
        "os"
        "path"
        "strings"
        "sync/atomic"
        "time"

        "github.com/gomodule/redigo/redis"
        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/spf13/viper"
        httpSwagger "github.com/swaggo/http-swagger"
        "github.com/swaggo/swag"
        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
        core_logging "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-logging/json"
        core_metrics "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-metrics"
        core_tracing "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-tracing"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"

        _ "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/api/docs"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/fscache"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/metrics"
)

// @title Service API
// @version 2.0
// @description Go microservice template for Kubernetes.

// @contact.name Source Code
// @contact.url https://github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service

// @license.name MIT License
// @license.url https://github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/blob/master/LICENSE

// @host localhost:9898
// @BasePath /
// @schemes http https

var (
        healthy int32
        ready   int32
        watcher *fscache.Watcher
)

type Config struct {
        HttpClientTimeout         time.Duration `mapstructure:"http-client-timeout"`
        HttpServerTimeout         time.Duration `mapstructure:"http-server-timeout"`
        HttpServerShutdownTimeout time.Duration `mapstructure:"http-server-shutdown-timeout"`
        BackendURL                []string      `mapstructure:"backend-url"`
        UILogo                    string        `mapstructure:"ui-logo"`
        UIMessage                 string        `mapstructure:"ui-message"`
        UIColor                   string        `mapstructure:"ui-color"`
        UIPath                    string        `mapstructure:"ui-path"`
        DataPath                  string        `mapstructure:"data-path"`
        ConfigPath                string        `mapstructure:"config-path"`
        CertPath                  string        `mapstructure:"cert-path"`
        Port                      string        `mapstructure:"port"`
        SecurePort                string        `mapstructure:"secure-port"`
        PortMetrics               int           `mapstructure:"port-metrics"`
        Hostname                  string        `mapstructure:"hostname"`
        H2C                       bool          `mapstructure:"h2c"`
        RandomDelay               bool          `mapstructure:"random-delay"`
        RandomDelayUnit           string        `mapstructure:"random-delay-unit"`
        RandomDelayMin            int           `mapstructure:"random-delay-min"`
        RandomDelayMax            int           `mapstructure:"random-delay-max"`
        RandomError               bool          `mapstructure:"random-error"`
        Unhealthy                 bool          `mapstructure:"unhealthy"`
        Unready                   bool          `mapstructure:"unready"`
        JWTSecret                 string        `mapstructure:"jwt-secret"`
        CacheServer               string        `mapstructure:"cache-server"`
}

type Server struct {
        router        *mux.Router
        config        *Config
        pool          *redis.Pool
        handler       http.Handler
        authnClient   core_auth_sdk.AuthService
        logger        core_logging.ILog
        metrics       *metrics.CoreMetrics
        metricsEngine *core_metrics.CoreMetricsEngine
        tracerEngine  *core_tracing.TracingEngine
}

func NewServer(config *Config, client core_auth_sdk.AuthService, logging core_logging.ILog, serviceMetrics *metrics.CoreMetrics,
        metricsEngineConf *core_metrics.CoreMetricsEngine, tracer *core_tracing.TracingEngine) (*Server, error) <span class="cov0" title="0">{
        srv := &amp;Server{
                router: mux.NewRouter(),
                logger: logging,
                config: config,
        }

        return srv, nil
}</span>

func (s *Server) registerHandlers() <span class="cov0" title="0">{
        s.router.Handle("/metrics", promhttp.Handler())
        s.router.PathPrefix("/debug/pprof/").Handler(http.DefaultServeMux)
        s.router.HandleFunc("/", s.indexHandler).HeadersRegexp("User-Agent", "^Mozilla.*").Methods("GET")
        s.router.HandleFunc("/", s.infoHandler).Methods("GET")
        s.router.HandleFunc("/version", s.versionHandler).Methods("GET")
        s.router.HandleFunc("/echo", s.echoHandler).Methods("POST")
        s.router.HandleFunc("/env", s.envHandler).Methods("GET", "POST")
        s.router.HandleFunc("/headers", s.echoHeadersHandler).Methods("GET", "POST")
        s.router.HandleFunc("/delay/{wait:[0-9]+}", s.delayHandler).Methods("GET").Name("delay")
        s.router.HandleFunc("/healthz", s.healthzHandler).Methods("GET")
        s.router.HandleFunc("/readyz", s.readyzHandler).Methods("GET")
        s.router.HandleFunc("/readyz/enable", s.enableReadyHandler).Methods("POST")
        s.router.HandleFunc("/readyz/disable", s.disableReadyHandler).Methods("POST")
        s.router.HandleFunc("/panic", s.panicHandler).Methods("GET")
        s.router.HandleFunc("/status/{code:[0-9]+}", s.statusHandler).Methods("GET", "POST", "PUT").Name("status")
        s.router.HandleFunc("/store", s.storeWriteHandler).Methods("POST", "PUT")
        s.router.HandleFunc("/store/{hash}", s.storeReadHandler).Methods("GET").Name("store")
        s.router.HandleFunc("/cache/{key}", s.cacheWriteHandler).Methods("POST", "PUT")
        s.router.HandleFunc("/cache/{key}", s.cacheDeleteHandler).Methods("DELETE")
        s.router.HandleFunc("/cache/{key}", s.cacheReadHandler).Methods("GET").Name("cache")
        s.router.HandleFunc("/configs", s.configReadHandler).Methods("GET")
        s.router.HandleFunc("/token", s.tokenGenerateHandler).Methods("POST")
        s.router.HandleFunc("/token/validate", s.tokenValidateHandler).Methods("GET")
        s.router.HandleFunc("/api/info", s.infoHandler).Methods("GET")
        s.router.HandleFunc("/api/echo", s.echoHandler).Methods("POST")
        s.router.HandleFunc("/ws/echo", s.echoWsHandler)
        s.router.HandleFunc("/chunked", s.chunkedHandler)
        s.router.HandleFunc("/chunked/{wait:[0-9]+}", s.chunkedHandler)
        s.router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
        ))
        s.router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
        ))
        s.router.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                doc, err := swag.ReadDoc()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err, "swagger error", zap.Error(err), zap.String("path", "/swagger.json"))
                }</span>
                <span class="cov0" title="0">w.Write([]byte(doc))</span>
        })
}

func (s *Server) registerMiddlewares() <span class="cov0" title="0">{
        prom := NewPrometheusMiddleware()
        s.router.Use(prom.Handler)
        httpLogger := NewLoggingMiddleware(s.logger)
        s.router.Use(httpLogger.Handler)
        s.router.Use(versionMiddleware)
        if s.config.RandomDelay </span><span class="cov0" title="0">{
                randomDelayer := NewRandomDelayMiddleware(s.config.RandomDelayMin, s.config.RandomDelayMax, s.config.RandomDelayUnit)
                s.router.Use(randomDelayer.Handler)
        }</span>
        <span class="cov0" title="0">if s.config.RandomError </span><span class="cov0" title="0">{
                s.router.Use(randomErrorMiddleware)
        }</span>
}

func (s *Server) ListenAndServe(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        go s.startMetricsServer()

        s.registerHandlers()
        s.registerMiddlewares()

        if s.config.H2C </span><span class="cov0" title="0">{
                s.handler = h2c.NewHandler(s.router, &amp;http2.Server{})
        }</span> else<span class="cov0" title="0"> {
                s.handler = s.router
        }</span>

        // s.printRoutes()

        // load configs in memory and start watching for changes in the config dir
        <span class="cov0" title="0">if stat, err := os.Stat(s.config.ConfigPath); err == nil &amp;&amp; stat.IsDir() </span><span class="cov0" title="0">{
                var err error
                watcher, err = fscache.NewWatch(s.config.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err, "config watch error", zap.Error(err), zap.String("path", s.config.ConfigPath))
                }</span> else<span class="cov0" title="0"> {
                        watcher.Watch()
                }</span>
        }

        // start redis connection pool
        <span class="cov0" title="0">ticker := time.NewTicker(30 * time.Second)
        s.startCachePool(ticker, stopCh)

        // create the http server
        srv := s.startServer()

        // create the secure server
        secureSrv := s.startSecureServer()

        // signal Kubernetes the server is ready to receive traffic
        if !s.config.Unhealthy </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;healthy, 1)
        }</span>
        <span class="cov0" title="0">if !s.config.Unready </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;ready, 1)
        }</span>

        // wait for SIGTERM or SIGINT
        <span class="cov0" title="0">&lt;-stopCh
        ctx, cancel := context.WithTimeout(context.Background(), s.config.HttpServerShutdownTimeout)
        defer cancel()

        // all calls to /healthz and /readyz will fail from now on
        atomic.StoreInt32(&amp;healthy, 0)
        atomic.StoreInt32(&amp;ready, 0)

        // close cache pool
        if s.pool != nil </span><span class="cov0" title="0">{
                _ = s.pool.Close()
        }</span>

        <span class="cov0" title="0">s.logger.Info("Shutting down HTTP/HTTPS server", zap.Duration("timeout", s.config.HttpServerShutdownTimeout))

        // wait for Kubernetes readiness probe to remove this instance from the load balancer
        // the readiness check interval must be lower than the timeout
        if viper.GetString("level") != "debug" </span><span class="cov0" title="0">{
                time.Sleep(3 * time.Second)
        }</span>

        // determine if the http server was started
        <span class="cov0" title="0">if srv != nil </span><span class="cov0" title="0">{
                if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err, "HTTP server graceful shutdown failed", zap.Error(err))
                }</span>
        }

        // determine if the secure server was started
        <span class="cov0" title="0">if secureSrv != nil </span><span class="cov0" title="0">{
                if err := secureSrv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err, "HTTPS server graceful shutdown failed", zap.Error(err))
                }</span>
        }
}

func (s *Server) startServer() *http.Server <span class="cov0" title="0">{

        // determine if the port is specified
        if s.config.Port == "0" </span><span class="cov0" title="0">{

                // move on immediately
                return nil
        }</span>

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         ":" + s.config.Port,
                WriteTimeout: s.config.HttpServerTimeout,
                ReadTimeout:  s.config.HttpServerTimeout,
                IdleTimeout:  2 * s.config.HttpServerTimeout,
                Handler:      s.handler,
        }

        // start the server in the background
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.FatalM(err, "HTTP server crashed")
                }</span>
        }()

        // return the server and routine
        <span class="cov0" title="0">return srv</span>
}

func (s *Server) startSecureServer() *http.Server <span class="cov0" title="0">{

        // determine if the port is specified
        if s.config.SecurePort == "0" </span><span class="cov0" title="0">{

                // move on immediately
                return nil
        }</span>

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         ":" + s.config.SecurePort,
                WriteTimeout: s.config.HttpServerTimeout,
                ReadTimeout:  s.config.HttpServerTimeout,
                IdleTimeout:  2 * s.config.HttpServerTimeout,
                Handler:      s.handler,
        }

        cert := path.Join(s.config.CertPath, "tls.crt")
        key := path.Join(s.config.CertPath, "tls.key")

        // start the server in the background
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServeTLS(cert, key); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.FatalM(err, "HTTPS server crashed")
                }</span>
        }()

        // return the server
        <span class="cov0" title="0">return srv</span>
}

func (s *Server) startMetricsServer() <span class="cov0" title="0">{
        if s.config.PortMetrics &gt; 0 </span><span class="cov0" title="0">{
                mux := http.DefaultServeMux
                mux.Handle("/metrics", promhttp.Handler())
                mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        w.Write([]byte("OK"))
                }</span>)

                <span class="cov0" title="0">srv := &amp;http.Server{
                        Addr:    fmt.Sprintf(":%v", s.config.PortMetrics),
                        Handler: mux,
                }

                srv.ListenAndServe()</span>
        }
}

func (s *Server) printRoutes() <span class="cov0" title="0">{
        s.router.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error </span><span class="cov0" title="0">{
                pathTemplate, err := route.GetPathTemplate()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("ROUTE:", pathTemplate)
                }</span>
                <span class="cov0" title="0">pathRegexp, err := route.GetPathRegexp()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Path regexp:", pathRegexp)
                }</span>
                <span class="cov0" title="0">queriesTemplates, err := route.GetQueriesTemplates()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Queries templates:", strings.Join(queriesTemplates, ","))
                }</span>
                <span class="cov0" title="0">queriesRegexps, err := route.GetQueriesRegexp()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Queries regexps:", strings.Join(queriesRegexps, ","))
                }</span>
                <span class="cov0" title="0">methods, err := route.GetMethods()
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Println("Methods:", strings.Join(methods, ","))
                }</span>
                <span class="cov0" title="0">fmt.Println()
                return nil</span>
        })
}

type ArrayResponse []string
type MapResponse map[string]string
</pre>
		
		<pre class="file" id="file18" style="display: none">package api

import (
        "net/http"

        "strconv"

        "github.com/gorilla/mux"
)

// Status godoc
// @Summary Status code
// @Description sets the response status code to the specified code
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /status/{code} [get]
// @Success 200 {object} api.MapResponse
func (s *Server) statusHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)

        code, err := strconv.Atoi(vars["code"])
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">s.JSONResponseCode(w, r, map[string]int{"status": code}, code)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package api

import (
        "crypto/sha1"
        "encoding/hex"
        "io/ioutil"
        "net/http"
        "path"

        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

// Store godoc
// @Summary Upload file
// @Description writes the posted content to disk at /data/hash and returns the SHA1 hash of the content
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /store [post]
// @Success 200 {object} api.MapResponse
func (s *Server) storeWriteHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "reading the request body failed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hash := hash(string(body))
        err = ioutil.WriteFile(path.Join(s.config.DataPath, hash), body, 0644)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Info("writing file failed", zap.Error(err), zap.String("file", path.Join(s.config.DataPath, hash)))
                s.ErrorResponse(w, r, "writing file failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">s.JSONResponseCode(w, r, map[string]string{"hash": hash}, http.StatusAccepted)</span>
}

// Store godoc
// @Summary Download file
// @Description returns the content of the file /data/hash if exists
// @Tags HTTP API
// @Accept json
// @Produce plain
// @Router /store/{hash} [get]
// @Success 200 {string} string "file"
func (s *Server) storeReadHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hash := mux.Vars(r)["hash"]
        content, err := ioutil.ReadFile(path.Join(s.config.DataPath, hash))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Info("reading file failed", zap.Error(err), zap.String("file", path.Join(s.config.DataPath, hash)))
                s.ErrorResponse(w, r, "reading file failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusAccepted)
        w.Write([]byte(content))</span>
}

func hash(input string) string <span class="cov0" title="0">{
        h := sha1.New()
        h.Write([]byte(input))
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package api

import (
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
        "go.uber.org/zap"
)

type jwtCustomClaims struct {
        Name string `json:"name"`
        jwt.StandardClaims
}

// Token godoc
// @Summary Generate JWT token
// @Description issues a JWT token valid for one minute
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /token [post]
// @Success 200 {object} api.TokenResponse
func (s *Server) tokenGenerateHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err, "reading the request body failed", zap.Error(err))
                s.ErrorResponse(w, r, "invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        user := "anonymous"
        if len(body) &gt; 0 </span><span class="cov0" title="0">{
                user = string(body)
        }</span>

        <span class="cov0" title="0">claims := &amp;jwtCustomClaims{
                user,
                jwt.StandardClaims{
                        Issuer:    "service",
                        ExpiresAt: time.Now().Add(time.Minute * 1).Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        t, err := token.SignedString([]byte(s.config.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var result = TokenResponse{
                Token:     t,
                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0),
        }

        s.JSONResponse(w, r, result)</span>
}

// TokenValidate godoc
// @Summary Validate JWT token
// @Description validates the JWT token
// @Tags HTTP API
// @Accept json
// @Produce json
// @Router /token/validate [post]
// @Success 200 {object} api.TokenValidationResponse
// @Failure 401 {string} string "Unauthorized"
// Get: JWT=$(curl -s -d 'test' localhost:9898/token | jq -r .token)
// Post: curl -H "Authorization: Bearer ${JWT}" localhost:9898/token/validate
func (s *Server) tokenValidateHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        authorizationHeader := r.Header.Get("authorization")
        if authorizationHeader == "" </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "authorization bearer header required", http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">bearerToken := strings.Split(authorizationHeader, " ")
        if len(bearerToken) != 2 || strings.ToLower(bearerToken[0]) != "bearer" </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, "authorization bearer header required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">claims := jwtCustomClaims{}
        token, err := jwt.ParseWithClaims(bearerToken[1], &amp;claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid signing method")
                }</span>
                <span class="cov0" title="0">return []byte(s.config.JWTSecret), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.ErrorResponse(w, r, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                if claims.StandardClaims.Issuer != "service" </span><span class="cov0" title="0">{
                        s.ErrorResponse(w, r, "invalid issuer", http.StatusUnauthorized)
                }</span> else<span class="cov0" title="0"> {
                        var result = TokenValidationResponse{
                                TokenName: claims.Name,
                                ExpiresAt: time.Unix(claims.StandardClaims.ExpiresAt, 0),
                        }
                        s.JSONResponse(w, r, result)
                }</span>
        } else<span class="cov0" title="0"> {
                s.ErrorResponse(w, r, "Invalid authorization token", http.StatusUnauthorized)
        }</span>
}

type TokenResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
}

type TokenValidationResponse struct {
        TokenName string    `json:"token_name"`
        ExpiresAt time.Time `json:"expires_at"`
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package api

import (
        "net/http"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/version"
)

// Version godoc
// @Summary
// @Description returns service version and git commit hash
// @Tags HTTP API
// @Produce json
// @Router /version [get]
// @Success 200 {object} api.MapResponse
func (s *Server) versionHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        result := map[string]string{
                "version": version.VERSION,
                "commit":  version.REVISION,
        }
        s.JSONResponse(w, r, result)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package grpc

import (
        "context"
        "errors"
        "fmt"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// AuthenticateAccount authenticates the current user account against the authentication service ensuring the credentials defined exist
func (s *Server) AuthenticateAccount(ctx context.Context, req *proto.AuthenticateAccountRequest) (*proto.AuthenticateAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.LOGIN_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.LOGIN_ACCOUNT).Inc()

                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid email and password")

                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        return s.authnClient.LoginAccount(req.Email, req.Password)
                }</span>
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        result, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.LOGIN_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">token := fmt.Sprintf("%v", result)
        if token == "" </span><span class="cov0" title="0">{
                s.metrics.CastingOperationFailureCounter.WithLabelValues(constants.LOGIN_ACCOUNT)
                err := errors.New("issue casting to jwt token")
                s.logger.For(ctx).ErrorM(err, "casting error")
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully authenticated user account", zap.String("jwt", token))
        response := &amp;proto.AuthenticateAccountResponse{
                Token: token,
                Error: "",
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package grpc

import (
        "context"
        "errors"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// CreateAccount creates a user account via the authentication service
func (s *Server) CreateAccount(ctx context.Context, req *proto.CreateAccountRequest) (*proto.CreateAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.CREATE_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.CREATE_ACCOUNT).Inc()

                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid username and password")

                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                isAccountLocked = false
                operation       = func() (interface{}, error) </span><span class="cov8" title="1">{
                        return s.authnClient.ImportAccount(req.Email, req.Password, isAccountLocked)
                }</span>
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        result, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.CREATE_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">id, ok := result.(int)
        if !ok </span><span class="cov0" title="0">{
                s.metrics.CastingOperationFailureCounter.WithLabelValues(constants.CREATE_ACCOUNT)
                err := errors.New("failed to convert result to uint32 id value")
                s.logger.For(ctx).ErrorM(err, "casting error")
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully created user account", zap.Int("Id", int(id)))
        response := &amp;proto.CreateAccountResponse{Id: uint32(id), Error: ""}

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package grpc

import (
        "context"
        "strconv"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// DeleteAccount deletes a user account via the authentication service
func (s *Server) DeleteAccount(ctx context.Context, req *proto.DeleteAccountRequest) (*proto.DeleteAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.DELETE_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.DELETE_ACCOUNT).Inc()
                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid user id")
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        if err := s.authnClient.ArchiveAccount(strconv.Itoa(int(req.GetId()))); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return nil, nil</span>
                }
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        _, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.DELETE_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully archived user account", zap.Int("Id", int(req.GetId())))
        return &amp;proto.DeleteAccountResponse{
                Error: "",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package grpc

import (
        "context"
        "strconv"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// GetAccount obtains an account as long as the account exists from the context of the authentication service
func (s *Server) GetAccount(ctx context.Context, req *proto.GetAccountRequest) (*proto.GetAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.GET_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.GET_ACCOUNT).Inc()
                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid user id")
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        account, err := s.authnClient.GetAccount(strconv.Itoa(int(req.GetId())))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return account, nil</span>
                }
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        result, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.GET_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">account, ok := result.(*core_auth_sdk.Account)
        if !ok </span><span class="cov0" title="0">{
                s.metrics.CastingOperationFailureCounter.WithLabelValues(constants.GET_ACCOUNT)

                err := service_errors.ErrFailedToCastAccount
                s.logger.For(ctx).ErrorM(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully obtained user account", zap.Int("Id", int(req.GetId())))
        return &amp;proto.GetAccountResponse{
                Account: &amp;proto.Account{
                        Id:            uint32(account.ID),
                        Username:      account.Username,
                        Locked:        account.Locked,
                        Deleted:       account.Deleted,
                        XXX_sizecache: 0,
                },
                Error: "",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package grpc

import (
        "context"
        "strconv"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// LockAccount locks an account as long as it exists from the context of the authentication service
func (s *Server) LockAccount(ctx context.Context, req *proto.LockAccountRequest) (*proto.LockAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.LOCK_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.LOCK_ACCOUNT).Inc()
                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid user id")
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        if err := s.authnClient.LockAccount(strconv.Itoa(int(req.GetId()))); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return nil, nil</span>
                }
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        _, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.LOCK_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully locked user account", zap.Int("Id", int(req.GetId())))
        return &amp;proto.LockAccountResponse{
                Error: "",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package grpc

import (
        "context"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// LogoutAccount revokes the user account session from the context of the authentication service
func (s *Server) LogoutAccount(ctx context.Context, req *proto.LogoutAccountRequest) (*proto.LogoutAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.LOGOUT_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.LOGOUT_ACCOUNT).Inc()

                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid user id")

                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        return nil, s.authnClient.LogOutAccount()
                }</span>
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        _, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.LOGOUT_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully logged out user account", zap.Int("id", int(req.GetId())))
        response := &amp;proto.LogoutAccountResponse{
                Error: "",
        }
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package grpc

import (
        "context"
        "io"
        "log"
        "net"
        "time"

        "github.com/opentracing/opentracing-go"
        "github.com/uber/jaeger-lib/metrics/prometheus"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/test/bufconn"

        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
        core_logging "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-logging/json"
        core_metrics "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-metrics"
        core_tracing "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-tracing"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/metrics"
)

type MockAuthGRPCServer struct {
        proto.UnimplementedAuthenticationHandlerServiceApiServer
}

type MockDialOption func(context.Context, string) (net.Conn, error)

// dialer creates an in memory full duplex connection
func dialer(authClientMock core_auth_sdk.AuthService) func() MockDialOption <span class="cov8" title="1">{
        return func() MockDialOption </span><span class="cov8" title="1">{
                listener := bufconn.Listen(1024 * 1024)

                server := grpc.NewServer()
                s := NewMockServer(authClientMock)
                proto.RegisterAuthenticationHandlerServiceApiServer(server, s)

                go func() </span><span class="cov8" title="1">{
                        if err := server.Serve(listener); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }()

                <span class="cov8" title="1">return func(context.Context, string) (net.Conn, error) </span><span class="cov8" title="1">{
                        return listener.Dial()
                }</span>
        }
}

// MockGRPCService creates and returns a mock grpc service connection
func MockGRPCService(ctx context.Context, authClientMock core_auth_sdk.AuthService) *grpc.ClientConn <span class="cov8" title="1">{
        conn, err := grpc.DialContext(ctx, "", grpc.WithInsecure(), grpc.WithContextDialer(dialer(authClientMock)()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return conn</span>
}

// NewMockServer creates a new mock server instance
func NewMockServer(authClientMockStub core_auth_sdk.AuthService) *Server <span class="cov8" title="1">{
        config := &amp;Config{
                Port:            9897,
                ServiceName:     "AuthenticationHandlerService",
                RpcDeadline:     60 * 1000000,
                RpcRetries:      1,
                RpcRetryTimeout: 10,
                RpcRetryBackoff: 1,
        }

        // initiate tracing engine
        tracerEngine, closer := InitializeTracingEngine(config.ServiceName)
        defer closer.Close()
        ctx := context.Background()

        // initiate metrics engine
        serviceMetrics := InitializeMetricsEngine(config.ServiceName)

        // initiate logging client
        logger := InitializeLoggingEngine(ctx)

        srv := &amp;Server{
                config:        config,
                tracerEngine:  tracerEngine,
                metricsEngine: serviceMetrics.Engine,
                metrics:       serviceMetrics.MicroServiceMetrics,
                logger:        logger,
                authnClient:   authClientMockStub,
        }

        return srv
}</span>

// InitializeAuthnClient creates a connection to the authn service
func InitializeAuthnClient(logger core_logging.ILog) (core_auth_sdk.AuthService, error) <span class="cov0" title="0">{
        client, err := core_auth_sdk.NewClient(core_auth_sdk.Config{
                // The AUTHN_URL of your Keratin AuthN server. This will be used to verify tokens created by
                // AuthN, and will also be used for API calls unless PrivateBaseURL is also set.
                Issuer: constants.TEST_ISSUER,

                // The domain of your application (no protocol). This domain should be listed in the APP_DOMAINS
                // of your Keratin AuthN server.
                Audience: constants.TEST_AUDIENCE,

                // Credentials for AuthN's private endpoints. These will be used to execute admin actions using
                // the Client provided by this library.
                //
                // TIP: make them extra secure in production!
                Username: constants.TEST_USERNAME,
                Password: constants.TEST_PASSWORD,

                // RECOMMENDED: Send private API calls to AuthN using private network routing. This can be
                // necessary if your environment has a firewall to limit public endpoints.
                PrivateBaseURL: constants.TEST_BASE_URL,
        }, constants.TEST_ORIGIN)

        // TODO: make this a retryable operation
        retries := 1
        for retries &lt; 4 </span><span class="cov0" title="0">{
                // perform a test request to the authentication service
                data, err := client.ServerStats()
                if err != nil </span><span class="cov0" title="0">{
                        if retries != 4 </span><span class="cov0" title="0">{
                                logger.ErrorM(err, "failed to connect to authentication service")
                        }</span> else<span class="cov0" title="0"> {
                                logger.FatalM(err, "failed to connect to authentication service")
                        }</span>
                        <span class="cov0" title="0">retries += 1</span>
                } else<span class="cov0" title="0"> {
                        retries = 4
                        logger.InfoM("data", zap.Any("result", data))
                }</span>

                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov0" title="0">return client, err</span>
}

// InitializeLoggingEngine initializes logging object
func InitializeLoggingEngine(ctx context.Context) core_logging.ILog <span class="cov8" title="1">{
        rootSpan := opentracing.SpanFromContext(ctx)
        logger := core_logging.NewJSONLogger(nil, rootSpan)
        return logger
}</span>

// InitializeMetricsEngine initializes a metrics engine globally
func InitializeMetricsEngine(serviceName string) *metrics.MetricsEngine <span class="cov8" title="1">{
        coreMetrics := core_metrics.NewCoreMetricsEngineInstance(serviceName, nil)
        serviceMetrics := metrics.NewMetricsEngine(coreMetrics, "mock")
        return serviceMetrics
}</span>

// InitializeTracingEngine initiaize a tracing object globally
func InitializeTracingEngine(serviceName string) (*core_tracing.TracingEngine, io.Closer) <span class="cov8" title="1">{
        return core_tracing.NewTracer(serviceName, constants.COLLECTOR_ENDPOINT, prometheus.New())
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package grpc

import (
        "context"
        "time"

        "github.com/giantswarm/retry-go"
        "github.com/opentracing/opentracing-go"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

type RpcOperationFunc func() (interface{}, error)

// setCtxRequestTimeout sets the request deadline in the context. This function should be invoked prior to any rpc calls
func (s *Server) setCtxRequestTimeout(ctx context.Context) context.Context <span class="cov8" title="1">{
        clientDeadline := time.Now().Add(time.Duration(s.config.RpcDeadline) * time.Millisecond)
        ctx, _ = context.WithDeadline(ctx, clientDeadline)
        return ctx
}</span>

// performRetryableRpcCall performs an rpc call using retries in the face of errors
func (s *Server) performRetryableRpcCall(ctx context.Context, f func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        var response = make(chan interface{}, 1)

        err := retry.Do(
                func(conn chan&lt;- interface{}) func() error </span><span class="cov8" title="1">{
                        return func() error </span><span class="cov8" title="1">{
                                opResponse, err := f()
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">response &lt;- opResponse
                                return nil</span>
                        }
                }(response),
                retry.MaxTries(s.config.RpcRetries),
                retry.Timeout(time.Millisecond*time.Duration(s.config.RpcDeadline)),
                retry.Sleep(time.Millisecond*time.Duration(s.config.RpcRetryBackoff)),
        )

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                return nil, service_errors.ErrRequestTimeout
        }</span>

        <span class="cov8" title="1">return &lt;-response, nil</span>
}

// PerformRetryableRPCOperation performs a retryable operation
func (s *Server) PerformRetryableRPCOperation(ctx context.Context, span opentracing.Span, op RpcOperationFunc, opType string) RpcOperationFunc <span class="cov8" title="1">{
        return func() (interface{}, error) </span><span class="cov8" title="1">{
                var (
                        begin = time.Now()
                        took  = time.Since(begin)
                )

                retryableOp := func() (interface{}, error) </span><span class="cov8" title="1">{
                        return s.performRetryableRpcCall(ctx, op)
                }</span>

                <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, span)
                return s.performRPCOperationAndInstrument(ctx, retryableOp, opType, &amp;took)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package grpc

import (
        "fmt"
        "net"

        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"

        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
        core_logging "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-logging/json"
        core_metrics "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-metrics"
        core_tracing "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-tracing"

        otgrpc "github.com/opentracing-contrib/go-grpc"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/metrics"
)

type Server struct {
        // inherit the behaviors/adhere to the interface the api server adheres to
        proto.UnimplementedAuthenticationHandlerServiceApiServer
        config        *Config
        authnClient   core_auth_sdk.AuthService
        logger        core_logging.ILog
        metrics       *metrics.CoreMetrics
        metricsEngine *core_metrics.CoreMetricsEngine
        tracerEngine  *core_tracing.TracingEngine
}

type Config struct {
        Port            int    `mapstructure:"grpc-port"`
        ServiceName     string `mapstructure:"grpc-service-name"`
        RpcDeadline     int    `mapstructure:"grpc-rpc-deadline"`
        RpcRetries      int    `mapstructure:"grpc-rpc-retries"`
        RpcRetryTimeout int    `mapstructure:"grpc-rpc-retry-timeout"`
        RpcRetryBackoff int    `mapstructure:"grpc-rpc-retry-backoff"`
}

// NewServer defines a new instance of the grpc service
func NewServer(config *Config, client core_auth_sdk.AuthService, logging core_logging.ILog, serviceMetrics *metrics.CoreMetrics,
        metricsEngineConf *core_metrics.CoreMetricsEngine, tracer *core_tracing.TracingEngine) (*Server, error) <span class="cov0" title="0">{
        srv := &amp;Server{
                logger:        logging,
                metrics:       serviceMetrics,
                authnClient:   client,
                metricsEngine: metricsEngineConf,
                tracerEngine:  tracer,
                config:        config,
        }

        return srv, nil
}</span>

// ListenAndServe starts the grpc service
func (s *Server) ListenAndServe() <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", fmt.Sprintf(":%v", s.config.Port))
        if err != nil </span><span class="cov0" title="0">{
                var msg = fmt.Sprintf("faled to listen on port %d", s.config.Port)
                s.logger.FatalM(err, msg)
        }</span>

        // configure tracing so all future rpc activity will be traced by use of s
        <span class="cov0" title="0">srv := grpc.NewServer(
                grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
                        grpc_ctxtags.StreamServerInterceptor(),
                        grpc_opentracing.StreamServerInterceptor(),
                        grpc_recovery.StreamServerInterceptor(),
                        otgrpc.OpenTracingStreamServerInterceptor(s.tracerEngine.Tracer),
                )),
                grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
                        grpc_ctxtags.UnaryServerInterceptor(),
                        grpc_opentracing.UnaryServerInterceptor(),
                        grpc_recovery.UnaryServerInterceptor(),
                        otgrpc.OpenTracingServerInterceptor(s.tracerEngine.Tracer)),
                ))

        server := health.NewServer()
        reflection.Register(srv)

        // use the auto generate code to register server
        proto.RegisterAuthenticationHandlerServiceApiServer(srv, s)
        grpc_health_v1.RegisterHealthServer(srv, server)
        server.SetServingStatus(s.config.ServiceName, grpc_health_v1.HealthCheckResponse_SERVING)

        if err := srv.Serve(listener); err != nil </span><span class="cov0" title="0">{
                var msg = fmt.Sprintf("faled to serve on port %d", s.config.Port)
                s.logger.FatalM(err, msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package grpc

import (
        core_auth_sdk "github.com/yoanyombapro1234/FeelGuuds/src/libraries/core/core-auth-sdk"
)

type AuthenticationServiceMock struct {
        GetAccountFunc     func(id string) (*core_auth_sdk.Account, error)
        UpdateAccountFunc  func(id, username string) error
        LockAccountFunc    func(id string) error
        UnlockAccountFunc  func(id string) error
        ArchiveAccountFunc func(id string) error
        ImportAccountFunc  func(username, password string, locked bool) (int, error)
        ExpirePasswordFunc func(id string) error
        LoginAccountFunc   func(username, password string) (string, error)
        SignupAccountFunc  func(username, password string) (string, error)
        LogOutAccountFunc  func() error
}

var ThirdPartyMockService = AuthenticationServiceMock{}

func (m *AuthenticationServiceMock) GetAccount(id string) (*core_auth_sdk.Account, error) <span class="cov8" title="1">{
        return m.GetAccountFunc(id)
}</span>

func (m *AuthenticationServiceMock) Update(id, username string) error <span class="cov8" title="1">{
        return m.UpdateAccountFunc(id, username)
}</span>

func (m *AuthenticationServiceMock) LockAccount(id string) error <span class="cov8" title="1">{
        return m.LockAccountFunc(id)
}</span>

func (m *AuthenticationServiceMock) UnlockAccount(id string) error <span class="cov8" title="1">{
        return m.UnlockAccountFunc(id)
}</span>

func (m *AuthenticationServiceMock) ArchiveAccount(id string) error <span class="cov8" title="1">{
        return m.ArchiveAccountFunc(id)
}</span>

func (m *AuthenticationServiceMock) ImportAccount(username, password string, locked bool) (int, error) <span class="cov8" title="1">{
        return m.ImportAccountFunc(username, password, locked)
}</span>

func (m *AuthenticationServiceMock) ExpirePassword(id string) error <span class="cov0" title="0">{
        return m.ExpirePasswordFunc(id)
}</span>

func (m *AuthenticationServiceMock) LoginAccount(username, password string) (string, error) <span class="cov8" title="1">{
        return m.LoginAccountFunc(username, password)
}</span>

func (m *AuthenticationServiceMock) SignupAccount(username, password string) (string, error) <span class="cov0" title="0">{
        return m.SignupAccountFunc(username, password)
}</span>

func (m *AuthenticationServiceMock) LogOutAccount() error <span class="cov8" title="1">{
        return m.LogOutAccountFunc()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package grpc

import (
        "context"
        "fmt"
        "time"

        "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
)

// PerformRPCOperationAndInstrument performs a rpc call to an external service and instruments the resulting response accordingly
func (s *Server) performRPCOperationAndInstrument(
        ctx context.Context,
        f func() (interface{}, error),
        operationType string,
        took *time.Duration) (interface{}, error) <span class="cov8" title="1">{

        authnSvcRpcSpan := s.tracerEngine.CreateChildSpan(ctx, fmt.Sprintf("AUTHENTICATION_SERVICE_%s_RPC_REQUEST", operationType))
        defer authnSvcRpcSpan.Finish()

        var status = constants.SUCCESS
        result, err := f()
        // error scenarios are only when the rpc request took too long or an error occured
        if err != nil || ctx.Err() == context.Canceled </span><span class="cov8" title="1">{
                status = constants.FAILURE
        }</span>

        <span class="cov8" title="1">s.metrics.RemoteOperationStatusCounter.WithLabelValues(operationType, status).Inc()
        s.metrics.RemoteOperationsLatencyCounter.WithLabelValues(operationType, status).Observe(took.Seconds())
        return result, err</span>
}

// StartRootSpan starts the rootspan of the current operation at hand
func (s *Server) StartRootSpan(ctx context.Context, operationType string) (context.Context, opentracing.Span) <span class="cov8" title="1">{
        s.logger.For(ctx).InfoM("GRPC request received", zap.String("method", operationType))

        spanCtx, _ := s.tracerEngine.Tracer.Extract(opentracing.HTTPHeaders, nil)
        parentSpan := s.tracerEngine.Tracer.StartSpan(operationType, ext.RPCServerOption(spanCtx))
        ctx = opentracing.ContextWithSpan(ctx, parentSpan)

        return ctx, parentSpan
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package grpc

import (
        "context"
        "strconv"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// UnLockAccount unlocks a user account from the context of the authentication service as long as the account exists
func (s *Server) UnLockAccount(ctx context.Context, req *proto.UnLockAccountRequest) (*proto.UnLockAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.UNLOCK_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.UNLOCK_ACCOUNT).Inc()
                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify a valid user id")
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        if err := s.authnClient.UnlockAccount(strconv.Itoa(int(req.GetId()))); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return nil, nil</span>
                }
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        _, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.UNLOCK_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully unlocked user account", zap.Int("Id", int(req.GetId())))
        return &amp;proto.UnLockAccountResponse{
                Error: "",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package grpc

import (
        "context"
        "strconv"

        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"

        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/gen/proto"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/constants"
        "github.com/yoanyombapro1234/FeelGuuds/src/services/authentication_handler_service/pkg/service_errors"
)

// UpdateAccount updates the account via the authentication services
func (s *Server) UpdateAccount(ctx context.Context, req *proto.UpdateAccountRequest) (*proto.UpdateAccountResponse, error) <span class="cov8" title="1">{
        ctx = s.setCtxRequestTimeout(ctx)
        ctx, parentSpan := s.StartRootSpan(ctx, constants.UPDATE_ACCOUNT)
        defer parentSpan.Finish()

        if req == nil </span><span class="cov0" title="0">{
                return nil, service_errors.ErrInvalidInputArguments
        }</span>

        <span class="cov8" title="1">if req.Email == "" || req.Id == 0 </span><span class="cov8" title="1">{
                s.metrics.InvalidRequestParametersCounter.WithLabelValues(constants.UPDATE_ACCOUNT).Inc()

                err := service_errors.ErrInvalidInputArguments
                s.logger.Error(err, "invalid input parameters. please specify an email or valid id")

                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                operation = func() (interface{}, error) </span><span class="cov8" title="1">{
                        return nil, s.authnClient.Update(strconv.Itoa(int(req.Id)), req.Email)
                }</span>
        )

        <span class="cov8" title="1">ctx = opentracing.ContextWithSpan(ctx, parentSpan)
        _, err := s.PerformRetryableRPCOperation(ctx, parentSpan, operation, constants.GET_ACCOUNT)()
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logger.For(ctx).Info("Successfully updated user account", zap.Int("Id", int(req.Id)))
        response := &amp;proto.UpdateAccountResponse{Error: ""}
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package grpc

import (
        "math/rand"
        "time"
        "unsafe"
)

var src = rand.NewSource(time.Now().UnixNano())

const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
const (
        letterIdxBits = 6                    // 6 bits to represent a letter index
        letterIdxMask = 1&lt;&lt;letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
        letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
)

// GenerateRandomString generates a random string based on the size specified by the client
func GenerateRandomString(n int) string <span class="cov8" title="1">{
        b := make([]byte, n)
        // A src.Int63() generates 63 random bits, enough for letterIdxMax characters!
        for i, cache, remain := n-1, src.Int63(), letterIdxMax; i &gt;= 0; </span><span class="cov8" title="1">{
                if remain == 0 </span><span class="cov8" title="1">{
                        cache, remain = src.Int63(), letterIdxMax
                }</span>
                <span class="cov8" title="1">if idx := int(cache &amp; letterIdxMask); idx &lt; len(letterBytes) </span><span class="cov8" title="1">{
                        b[i] = letterBytes[idx]
                        i--
                }</span>
                <span class="cov8" title="1">cache &gt;&gt;= letterIdxBits
                remain--</span>
        }

        <span class="cov8" title="1">return *(*string)(unsafe.Pointer(&amp;b))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
